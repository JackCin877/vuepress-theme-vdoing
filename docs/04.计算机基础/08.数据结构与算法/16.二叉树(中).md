---
title: äºŒå‰æ ‘(ä¸­)
date: 2023-09-13 09:07:39
permalink: /pages/86055b/
categories:
  - è®¡ç®—æœºåŸºç¡€
  - æ•°æ®ç»“æ„
tags:
  - 
author: 
  name: JackCin
  link: https://github.com/JackCin877
---
# äºŒå‰æ ‘(ä¸­)

## å…­ã€ç¿»è½¬äºŒå‰æ ‘

[226. ç¿»è½¬äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/invert-binary-tree/)

### 1ã€é¢˜ç›®

> ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œç¿»è½¬è¿™æ£µäºŒå‰æ ‘ï¼Œå¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚
>
> ![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> 
> è¾“å…¥ï¼šroot = [4,2,7,1,3,6,9]
> è¾“å‡ºï¼š[4,7,2,9,6,3,1]
> ```
>
> ![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)
>
> ```c
> ç¤ºä¾‹ 2ï¼š
> è¾“å…¥ï¼šroot = [2,1,3]
> è¾“å‡ºï¼š[2,3,1]
> ```
>
> ```c
> ç¤ºä¾‹ 3ï¼š
> 
> è¾“å…¥ï¼šroot = []
> è¾“å‡ºï¼š[]
> ```
>
> **æç¤ºï¼š**
>
> - æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®èŒƒå›´åœ¨ `[0, 100]` å†…
> - `-100 <= Node.val <= 100`

### 2ã€æ€è·¯

* è¿™é“é¢˜çš„æ€è·¯å¾ˆç®€å•,å°±æ˜¯**éå†æ¯ä¸€ä¸ªèŠ‚ç‚¹,ç„¶åå¯¹ä»–ä»¬çš„å·¦å³æŒ‡é’ˆè¿›è¡Œäº¤æ¢**,æ‰€ä»¥å†™æ³•æœ‰å¾ˆå¤š,æ¯”è¾ƒéœ€è¦æ³¨æ„çš„æ˜¯é€’å½’çš„ä¸­åºå†™æ³•
* ä¸Šé¢åŠ ç²—è¿™å¥å¾ˆé‡è¦,æ˜¯è§£é¢˜çš„æ ¸å¿ƒ
  * è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæ‰€æœ‰æ‰€æœ‰éå†æ–¹å¼åŸºæœ¬éƒ½å¯ä»¥çš„åŸå› ,å› ä¸ºæˆ‘ä»¬è¿™é“é¢˜çš„æ ¸å¿ƒå°±æ˜¯è¦éå†æ¯ä¸ªèŠ‚ç‚¹è€Œå·²
* é¢˜ç›®ç»™å‡ºçš„èŠ‚ç‚¹å®šä¹‰

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

```

### 3ã€è‡ªå·±èƒ¡ä¹±å†™çš„é€’å½’ğŸ˜«

```c
//å†™çš„æ—¶å€™çœ‹åˆ°å‡½æ•°æœ‰è¿”å›å€¼,å°±æƒ³ç€å¾—æœ‰ä¸ªå˜é‡å»æ¥æ”¶å‡½æ•°è°ƒç”¨æ—¶çš„è¿”å›å€¼,ç„¶åå°±å†™çš„å¥‡å¥‡æ€ªæ€ªçš„,è™½ç„¶å¥½åƒæ˜¯ååºéå†çš„æ„Ÿè§‰,ä½†æ€»è§‰å¾—å¥‡å¥‡æ€ªæ€ªçš„ğŸ˜°ğŸ˜°ğŸ˜°
struct TreeNode* invertTree(struct TreeNode* root){
    if(root==NULL){
        return NULL ;
    }
    struct TreeNode * l_node =  invertTree(root->left);
    struct TreeNode * r_node =  invertTree(root->right);
    root -> left = r_node;
    root -> right = l_node;
    
    return root;
}

```

### 4ã€æ·±åº¦éå†é€’å½’

```c
//é€’å½’å†™æ³•çš„æ·±åº¦éå†ï¼Œå‰åéå†éƒ½å¯ä»¥ï¼Œä½†æ˜¯ä¸­åºéå†ä¸è¡Œï¼Œå¦‚æœä¸€å®šè¦æŠŠäº¤æ¢æ“ä½œæ”¾åœ¨ä¸­é—´å¤„ç†çš„è¯ï¼Œé‚£ä¹ˆä¸¤æ¬¡è°ƒç”¨é€’å½’å‡½æ•°ä¼ å…¥çš„æŒ‡é’ˆå¿…é¡»éƒ½ä¸ºå·¦æˆ–å³æŒ‡é’ˆï¼Œå› ä¸ºä¸­é—´å¤„ç†è¿‡åï¼ŒæŒ‡é’ˆè¢«ç¿»è½¬äº†,é‚£ä¹ˆå°±å˜æˆäº† å·¦ä¸­å·¦,æˆ–è€…å³ä¸­å³çš„éå†,å°±ä¸ç¬¦åˆä¸­åºéå†å®šä¹‰äº†
//ä»¥ä¸‹ä¸ºå‰åºéå†
struct TreeNode* invertTree(struct TreeNode* root){
    if(root == NULL){
        return root;
    }
    struct TreeNode* node = root->left;  //ä¸­
    root ->left = root ->right;
    root->right = node;
    invertTree(root ->left); //å·¦
    invertTree(root ->right); //å³
    return root;
}
```

### 5ã€ç»Ÿä¸€å†™æ³•çš„æ·±åº¦éå†

```c
//ç»Ÿä¸€å†™æ³•æ·±åº¦éå†ï¼ˆæˆ‘ç§°ä¹‹ä¸ºç©ºæŒ‡é’ˆæ ‡å¿—æ³•ï¼‰ï¼Œå‰ä¸­ååºéƒ½å¯ä»¥
struct TreeNode* invertTree(struct TreeNode* root){
    if(root == NULL){
        return root;
    }
    struct TreeNode * stack[200];
    int top=0;
    stack[top++] =root;

    while(top>0){
        //æ³¨æ„è·å–æ ˆé¡¶å…ƒç´ è¦æ ˆé¡¶æŒ‡é’ˆå‡ä¸€
        struct TreeNode* node= stack[top-1];
        if(node != NULL){
            top--;  //å‡ºæ ˆ
            if(node -> right) stack[top++] = node ->right; //  å³
            stack[top++]= node;// ä¸­
            stack[top++]= NULL;
            if(node -> left) stack[top++] = node ->left;  // å·¦

            //å³ä¸­å·¦å‡ºæ ˆå°±ä¸º å·¦ä¸­å³å³ä¸­åºéå†
        }
        else {
            top--; //é‡åˆ°NULLå°±å¼¹å‡ºï¼Œå¹¶è¿›è¡Œå¤„ç†
            node = stack[--top];
            struct TreeNode * temp = node->left;
            node->left = node->right;
            node->right = temp;
        }
    }
    return root;
}
```

### 6ã€å±‚åºéå†

```c
struct TreeNode* invertTree(struct TreeNode* root){
    if(root==NULL){
        return NULL ;
    }
    struct TreeNode* queue[100];
    int front=0,rear=0;
    queue[rear++] =root;

    while(front != rear){
        int size = rear - front;
        for(int i=0;i<size;i++){
            struct TreeNode * node = queue[front++];
            //äº¤æ¢å·¦å³æŒ‡é’ˆ
            struct TreeNode * temp = node ->left;
            node ->left = node-> right;
            node ->right = temp;

            //ä¸‹é¢å“ªä¸ªå…ˆè¿›æ²¡åŒºåˆ«ï¼Œå› ä¸ºæˆ‘ä»¬ä¸»è¦æ˜¯è¦éå†æ¯ä¸ªç»“ç‚¹ç„¶åäº¤ä»–ä»¬çš„å·¦å³æŒ‡é’ˆè€Œå·²
            if(node->right) queue[rear++] = node->right;
            if(node->left) queue[rear++] = node->left;
            
        }
    }
    return root;
}
```

* å¦‚æœæœ‰ä¸ç†è§£,çœ‹[ä»£ç éšæƒ³å½• (programmercarl.com)](https://www.programmercarl.com/0226.ç¿»è½¬äºŒå‰æ ‘.html#é€’å½’æ³•)



## ä¸ƒã€å¯¹ç§°äºŒå‰æ ‘

[101. å¯¹ç§°äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/symmetric-tree/submissions/)

### 1ã€é¢˜ç›®

> ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œ æ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°ã€‚
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> è¾“å…¥ï¼šroot = [1,2,2,3,4,4,3]
> è¾“å‡ºï¼štrue
> ```
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)
>
> ```c
> ç¤ºä¾‹ 2ï¼š
> è¾“å…¥ï¼šroot = [1,2,2,null,3,null,3]
> è¾“å‡ºï¼šfalse
> ```
>
> **æç¤ºï¼š**
>
> - æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[1, 1000]` å†…
> - `-100 <= Node.val <= 100`

### 2ã€é€’å½’æ€è·¯

#### 2.1 ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼

* å› ä¸ºæˆ‘ä»¬è¦æ¯”è¾ƒçš„æ˜¯æ ¹èŠ‚ç‚¹çš„ä¸¤ä¸ªå­æ ‘æ˜¯å¦æ˜¯ç›¸äº’ç¿»è½¬çš„ï¼Œè¿›è€Œåˆ¤æ–­è¿™ä¸ªæ ‘æ˜¯ä¸æ˜¯å¯¹ç§°æ ‘ï¼Œæ‰€ä»¥è¦æ¯”è¾ƒçš„æ˜¯ä¸¤ä¸ªæ ‘ï¼Œå‚æ•°è‡ªç„¶ä¹Ÿæ˜¯å·¦å­æ ‘èŠ‚ç‚¹å’Œå³å­æ ‘èŠ‚ç‚¹ã€‚

* è¿”å›å€¼è‡ªç„¶æ˜¯boolç±»å‹ã€‚

* ä»£ç å¦‚ä¸‹ï¼š

```c
bool compare(TreeNode* left, TreeNode* right)
```



#### 2.2 ç¡®å®šç»ˆæ­¢æ¡ä»¶

* è¦æ¯”è¾ƒä¸¤ä¸ªèŠ‚ç‚¹æ•°å€¼ç›¸ä¸ç›¸åŒï¼Œé¦–å…ˆè¦æŠŠä¸¤ä¸ªèŠ‚ç‚¹ä¸ºç©ºçš„æƒ…å†µå¼„æ¸…æ¥šï¼å¦åˆ™åé¢æ¯”è¾ƒæ•°å€¼çš„æ—¶å€™å°±ä¼šæ“ä½œç©ºæŒ‡é’ˆäº†ã€‚

* èŠ‚ç‚¹ä¸ºç©ºçš„æƒ…å†µæœ‰ï¼šï¼ˆ**æ³¨æ„æˆ‘ä»¬æ¯”è¾ƒçš„å…¶å®ä¸æ˜¯å·¦å­©å­å’Œå³å­©å­ï¼Œæ‰€ä»¥å¦‚ä¸‹æˆ‘ç§°ä¹‹ä¸ºå·¦èŠ‚ç‚¹å³èŠ‚ç‚¹**ï¼‰

  - å·¦èŠ‚ç‚¹ä¸ºç©ºï¼Œå³èŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œä¸å¯¹ç§°ï¼Œreturn false

  - å·¦ä¸ä¸ºç©ºï¼Œå³ä¸ºç©ºï¼Œä¸å¯¹ç§° return false

  - å·¦å³éƒ½ä¸ºç©ºï¼Œå¯¹ç§°ï¼Œè¿”å›true

* æ­¤æ—¶å·²ç»æ’é™¤æ‰äº†èŠ‚ç‚¹ä¸ºç©ºçš„æƒ…å†µï¼Œé‚£ä¹ˆå‰©ä¸‹çš„å°±æ˜¯å·¦å³èŠ‚ç‚¹ä¸ä¸ºç©ºï¼š
  - å·¦å³éƒ½ä¸ä¸ºç©ºï¼Œæ¯”è¾ƒèŠ‚ç‚¹æ•°å€¼ï¼Œä¸ç›¸åŒå°±return false

* æ­¤æ—¶å·¦å³èŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œä¸”æ•°å€¼ä¹Ÿä¸ç›¸åŒçš„æƒ…å†µæˆ‘ä»¬ä¹Ÿå¤„ç†äº†ã€‚

* ä»£ç å¦‚ä¸‹ï¼š

```cpp
if (left == NULL && right != NULL) return false;
else if (left != NULL && right == NULL) return false;
else if (left == NULL && right == NULL) return true;
else if (left->val != right->val) return false; // æ³¨æ„è¿™é‡Œæˆ‘æ²¡æœ‰ä½¿ç”¨else
```

* æ³¨æ„ä¸Šé¢æœ€åä¸€ç§æƒ…å†µï¼Œæˆ‘æ²¡æœ‰ä½¿ç”¨elseï¼Œè€Œæ˜¯else ifï¼Œ å› ä¸ºæˆ‘ä»¬æŠŠä»¥ä¸Šæƒ…å†µéƒ½æ’é™¤ä¹‹åï¼Œå‰©ä¸‹çš„å°±æ˜¯ å·¦å³èŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºï¼Œä¸”æ•°å€¼ç›¸åŒçš„æƒ…å†µã€‚



#### 2.3 ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘

* æ­¤æ—¶æ‰è¿›å…¥å•å±‚é€’å½’çš„é€»è¾‘ï¼Œå•å±‚é€’å½’çš„é€»è¾‘å°±æ˜¯å¤„ç† å·¦å³èŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºï¼Œä¸”æ•°å€¼ç›¸åŒçš„æƒ…å†µã€‚

  - æ¯”è¾ƒäºŒå‰æ ‘å¤–ä¾§æ˜¯å¦å¯¹ç§°ï¼šä¼ å…¥çš„æ˜¯å·¦èŠ‚ç‚¹çš„å·¦å­©å­ï¼Œå³èŠ‚ç‚¹çš„å³å­©å­ã€‚

  - æ¯”è¾ƒå†…æµ‹æ˜¯å¦å¯¹ç§°ï¼Œä¼ å…¥å·¦èŠ‚ç‚¹çš„å³å­©å­ï¼Œå³èŠ‚ç‚¹çš„å·¦å­©å­ã€‚

  - å¦‚æœå·¦å³éƒ½å¯¹ç§°å°±è¿”å›true ï¼Œæœ‰ä¸€ä¾§ä¸å¯¹ç§°å°±è¿”å›false ã€‚

* ä»£ç å¦‚ä¸‹ï¼š

```cpp
bool outside = compare(left->left, right->right);   // å·¦å­æ ‘ï¼šå·¦ã€ å³å­æ ‘ï¼šå³
bool inside = compare(left->right, right->left);    // å·¦å­æ ‘ï¼šå³ã€ å³å­æ ‘ï¼šå·¦
bool isSame = outside && inside;                    // å·¦å­æ ‘ï¼šä¸­ã€ å³å­æ ‘ï¼šä¸­ï¼ˆé€»è¾‘å¤„ç†ï¼‰
return isSame;
```



### 3ã€é€’å½’ä»£ç 

```c
//é€’å½’å†™æ³•
bool compare(struct TreeNode* left,struct TreeNode* right){
    //å…ˆæ’é™¤ç©ºèŠ‚ç‚¹çš„æƒ…å†µ
    if (left == NULL && right!=NULL) return false;
    else if (left!=NULL && right ==NULL) return false;
    else if (left == NULL && right == NULL) return true;
    //æ’é™¤æ— ç©ºèŠ‚ç‚¹ï¼Œä½†æ•°ç»„ä¸åŒæƒ…å†µ
    else if (left->val != right ->val) return false;

    //å‰©ä¸‹å°±æ˜¯å·¦å³èŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œä¸”æ•°ç»„ç›¸åŒ
    //æ­¤æ—¶æ‰åšé€’å½’ï¼Œåšä¸‹ä¸€å±‚åˆ¤æ–­
    bool outside = compare(left->left,right ->right); //å·¦å­æ ‘ï¼šå·¦ã€å³å­æ ‘ï¼šå³
    bool inside = compare(left->right,right ->left);  //å·¦å­æ ‘ï¼šå³ã€å³å­æ ‘ï¼šå·¦
    bool isSame = outside && inside;        //å·¦å­æ ‘ï¼šä¸­ã€å³å­æ ‘ï¼šä¸­ï¼ˆé€»è¾‘å¤„ç†ï¼‰
    return isSame;
}

bool isSymmetric(struct TreeNode* root){
   if(root == NULL) return true;
   return compare(root->left,root->right);
}

```



### 4ã€è¿­ä»£æ€è·¯

* å› ä¸ºè¿™é“é¢˜çš„è¿­ä»£ä½¿ç”¨é˜Ÿåˆ—æˆ–è€…æ ˆéƒ½æ˜¯ä¸€ä¸ªæ€è·¯,å†™å‘ä¹ŸåŒºåˆ«ä¸å¤§,æ‰€ä»¥å°±ç”¨é˜Ÿåˆ—æ¥è®²è§£æ€è·¯
* é€šè¿‡é˜Ÿåˆ—æ¥åˆ¤æ–­æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘çš„å†…ä¾§å’Œå¤–ä¾§æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚åŠ¨ç”»æ‰€ç¤ºï¼š

![101.å¯¹ç§°äºŒå‰æ ‘](https://code-thinking.cdn.bcebos.com/gifs/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.gif)

* **ç®€å•æ¥è¯´: å°±æ˜¯æŠŠè¦åˆ¤æ–­çš„ä¸€å¯¹ä¸€èµ·æ”¾è¿›é˜Ÿåˆ—/æ ˆé‡Œ,åˆ¤æ–­å¤„ç†æ—¶ä¹Ÿä¸€èµ·å‡ºé˜Ÿ/æ ˆ**
  * æ³¨æ„å¤„ç†æ—¶, åˆ¤æ–­èŠ‚ç‚¹éƒ½ä¸ºç©ºå°± `continue`è·³è¿‡;
  * é‡åˆ°ä¸å¯¹ç§°æƒ…å†µå°±ç›´æ¥è¿”å› `false`;
  * é™¤æ­¤ä¹‹å¤– , æ­£å¸¸ä¸¤ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹è¿›é˜Ÿ/æ ˆ,åŒæ—¶æ”¾å› `true`

### 5ã€è¿­ä»£ä»£ç 

```c
//é˜Ÿåˆ—å†™æ³•ï¼Œè¦æ¯”è¾ƒçš„ä¸€å¯¹ä¸€å¯¹è¿›é˜Ÿï¼Œå‡ºé˜Ÿå¤„ç†
bool isSymmetric(struct TreeNode* root){
    if(root == NULL) return true;
    struct TreeNode* queue[1000];
    int front=0,rear=0;
    queue[rear++] = root->left;
    queue[rear++] = root->right;

    while(front != rear){
        struct TreeNode* l_node = queue[front++];
        struct TreeNode* r_node = queue[front++];
        //å·¦å³èŠ‚ç‚¹éƒ½éƒ½ä¸ºç©º 
        if(!l_node && !r_node) continue;
        
        // å·¦å³èŠ‚ç‚¹æœ‰ä¸€ä¸ªä¸ºç©ºï¼Œæˆ–è€…éƒ½ä¸ä¸ºç©ºä½†æ•°ç»„ä¸åŒ
        if(!l_node || !r_node || (l_node ->val != r_node ->val)){
            return false;
        }

        queue[rear++] = l_node->left;
        queue[rear++] = r_node->right;
        queue[rear++] = l_node->right;
        queue[rear++] = r_node->left;

    }
    return true;
}

```

```c
//æ ˆå†™æ³•ï¼Œè¦æ¯”è¾ƒçš„ä¸€å¯¹ä¸€å¯¹è¿›æ ˆï¼Œå‡ºé˜Ÿå¤„ç† ï¼ˆå’Œé˜Ÿåˆ—æ²¡æœ‰å¤ªå¤§åŒºåˆ«ï¼‰
bool isSymmetric(struct TreeNode* root){
    if(root == NULL) return true;
    struct TreeNode* stack[1000];
    int top=0;
    stack[top++] = root->left;
    stack[top++] = root->right;

    while(top>0){
        struct TreeNode* l_node =  stack[--top];
        struct TreeNode* r_node =  stack[--top];
        //å·¦å³èŠ‚ç‚¹éƒ½éƒ½ä¸ºç©º 
        if(!l_node && !r_node) continue;
        
        // å·¦å³èŠ‚ç‚¹æœ‰ä¸€ä¸ªä¸ºç©ºï¼Œæˆ–è€…éƒ½ä¸ä¸ºç©ºä½†æ•°ç»„ä¸åŒ
        if(!l_node || !r_node || (l_node ->val != r_node ->val)){
            return false;
        }

         stack[top++] = l_node->left;
         stack[top++] = r_node->right;
         stack[top++] = l_node->right;
         stack[top++] = r_node->left;

    }
    return true;
}
```



### 6ã€ç›¸ä¼¼é¢˜

#### 6.1 100.ç›¸åŒçš„æ ‘

- [100. ç›¸åŒçš„æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/same-tree/submissions/)
- æ€è·¯:ä¸å¯¹ç§°äºŒå‰æ ‘ç›¸ä¼¼,ä½†æ˜¯ä¸æ˜¯æŒ‰é‡Œä¾§å¤–ä¾§æ¥åˆ¤æ–­,è€Œæ˜¯å·¦å¯¹å·¦,å³å¯¹å³çš„åˆ¤æ–­

#### 6.2 572.å¦ä¸€ä¸ªæ ‘çš„å­æ ‘ğŸ˜£

- [572. å¦ä¸€æ£µæ ‘çš„å­æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/subtree-of-another-tree/)

* æ€è·¯ï¼šè¿™é¢˜æ¯”è¾ƒéš¾ï¼Œç”¨äº†åŒé‡é€’å½’ï¼Œå…ˆé€’å½’æ‰¾åˆ°ä¸å­æ ‘æ ¹ç»“ç‚¹æ•°ç»„ç›¸åŒçš„ç»“ç‚¹ï¼Œç„¶åå†é€’å½’åˆ¤æ–­å­æ ‘æ˜¯å¦å®Œå…¨ç›¸åŒ



## å…«ã€Nå‰æ ‘çš„æœ€å¤§æ·±åº¦

[559. N å‰æ ‘çš„æœ€å¤§æ·±åº¦ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/submissions/)

[ä»£ç éšæƒ³å½• (programmercarl.com)](https://www.programmercarl.com/0104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦.html#é€’å½’æ³•)

* ä¸Šé¢é“¾æ¥è™½ç„¶æ˜¯äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ï¼Œä½†æ˜¯ä¹Ÿæœ‰Nå‰æ ‘çš„



### 1ã€é¢˜ç›®

> ç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œæ‰¾åˆ°å…¶æœ€å¤§æ·±åº¦ã€‚
>
> æœ€å¤§æ·±åº¦æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ€»æ•°ã€‚
>
> N å‰æ ‘è¾“å…¥æŒ‰å±‚åºéå†åºåˆ—åŒ–è¡¨ç¤ºï¼Œæ¯ç»„å­èŠ‚ç‚¹ç”±ç©ºå€¼åˆ†éš”ï¼ˆè¯·å‚è§ç¤ºä¾‹ï¼‰ã€‚
>
> ![559.nå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://code-thinking-1253855093.file.myqcloud.com/pics/2021020315313214.png)
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> 
> è¾“å…¥ï¼šroot = [1,null,3,2,4,null,5,6]
> è¾“å‡ºï¼š3
> ```
>
>
> æç¤ºï¼š
>
> * æ ‘çš„æ·±åº¦ä¸ä¼šè¶…è¿‡ `1000` ã€‚
> * æ ‘çš„èŠ‚ç‚¹æ•°ç›®ä½äº `[0, 104]` ä¹‹é—´ã€‚
>
> ```c
> /**
>  * Definition for a Node.
>  * struct Node {
>  *     int val;
>  *     int numChildren;
>  *     struct Node** children;
>  * };
>  */
> ```
>
> 

### 2ã€é€’å½’

#### 2.1 æ€è·¯ä¸ä»£ç 

* é€’å½’åˆ°æ¯ä¸ªå­ç»“ç‚¹çš„æœ€æ·±å±‚ï¼Œç„¶ååˆ¤æ–­æ·±åº¦ï¼Œå†åŠ 1 ï¼Œå°±å¾—åˆ°äº†Nå‰æ ‘çš„æœ€å¤§æ·±åº¦

```c
//é€’å½’
int maxDepth(struct Node* root) {
    //ç»ˆæ­¢æ¡ä»¶
    if( root == NULL) return 0;
    //é€’å½’å¤„ç†
    int depth = 0;
    for(int i=0;i<root->numChildren;i++){
        int newdepth = maxDepth(root->children[i]);
        depth = depth > newdepth ? depth : newdepth;
    }
    return depth+1;
}
```

### 3ã€è¿­ä»£

#### 3.1 æ€è·¯ä¸ä»£ç 

* ä¸€å±‚ä¸€å±‚å…¥é˜Ÿï¼Œæ¯è¿›ä¸€å±‚ï¼Œæ·±åº¦åŠ ä¸€



```c
//é˜Ÿåˆ—å†™æ³•
int maxDepth(struct Node* root) {
    if(root == NULL) return 0;
    struct Node* queue[10000];
    int front=0,rear=0;
    queue[rear++] = root;
    int depth=0;

    while(front != rear)
    {
        int size = rear - front;
        for(int i=0;i<size;i++)
        {
            struct Node * node = queue[front++];
            for(int k=0;k < node-> numChildren; k++)
            {
                queue[rear++] = node->children[k];
            }
        }
        depth++;
    }
    return depth;
}
```





## ä¹ã€å®Œå…¨äºŒå‰æ ‘

[222. å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/count-complete-tree-nodes/)

[ä»£ç éšæƒ³å½• (programmercarl.com)](https://www.programmercarl.com/0222.å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°.html#æ™®é€šäºŒå‰æ ‘)

### 1ã€é¢˜ç›®

> ç»™ä½ ä¸€æ£µ **å®Œå…¨äºŒå‰æ ‘** çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ±‚å‡ºè¯¥æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚
>
> å®Œå…¨äºŒå‰æ ‘ çš„å®šä¹‰å¦‚ä¸‹ï¼šåœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œé™¤äº†æœ€åº•å±‚èŠ‚ç‚¹å¯èƒ½æ²¡å¡«æ»¡å¤–ï¼Œå…¶ä½™æ¯å±‚èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ï¼Œå¹¶ä¸”æœ€ä¸‹é¢ä¸€å±‚çš„èŠ‚ç‚¹éƒ½é›†ä¸­åœ¨è¯¥å±‚æœ€å·¦è¾¹çš„è‹¥å¹²ä½ç½®ã€‚è‹¥æœ€åº•å±‚ä¸ºç¬¬ h å±‚ï¼Œåˆ™è¯¥å±‚åŒ…å« 1~ 2h ä¸ªèŠ‚ç‚¹ã€‚
>
> 
>
> ![img](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> è¾“å…¥ï¼šroot = [1,2,3,4,5,6]
> è¾“å‡ºï¼š6
> 
> ç¤ºä¾‹ 2ï¼š
> è¾“å…¥ï¼šroot = []
> è¾“å‡ºï¼š0
> 
> ç¤ºä¾‹ 3ï¼š
> è¾“å…¥ï¼šroot = [1]
> è¾“å‡ºï¼š1
> ```
>
> **æç¤ºï¼š**
>
> - æ ‘ä¸­èŠ‚ç‚¹çš„æ•°ç›®èŒƒå›´æ˜¯`[0, 5 * 104]`
> - `0 <= Node.val <= 5 * 104`
> - é¢˜ç›®æ•°æ®ä¿è¯è¾“å…¥çš„æ ‘æ˜¯ **å®Œå…¨äºŒå‰æ ‘**



### 2ã€é€’å½’æ€è·¯åŠä»£ç 

* ååºé€’å½’éå†ï¼Œå…ˆæ±‚å®ƒçš„å·¦å­æ ‘çš„èŠ‚ç‚¹æ•°é‡ï¼Œå†æ±‚å³å­æ ‘çš„èŠ‚ç‚¹æ•°é‡ï¼Œæœ€åå–æ€»å’Œå†åŠ ä¸€ ï¼ˆåŠ 1æ˜¯å› ä¸ºç®—ä¸Šå½“å‰ä¸­é—´èŠ‚ç‚¹ï¼‰å°±æ˜¯ç›®å‰èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„èŠ‚ç‚¹æ•°é‡

```c
int countNodes(struct TreeNode* root){
    //é€’å½’ç»ˆæ­¢æ¡ä»¶
    if(root == NULL){
        return 0;
    }

    int leftnum = countNodes(root->left);   //å·¦
    int rightnum = countNodes(root -> right);  //å³
    return 1+ leftnum +rightnum;  //ä¸­

}
```

### 3ã€è¿­ä»£æ³•æ€è·¯åŠä»£ç 

* éå†æ¯ä¸ªèŠ‚ç‚¹ï¼Œè®°å½•æ•°å€¼åŠ ä¸€

```c
//æ ˆï¼Œè¿­ä»£
int countNodes(struct TreeNode* root){
    if(root == NULL) return 0;
    struct TreeNode* stack[25000];
    int top=0;
    stack[top++] = root;
    int count=0;

    while(top > 0){
        struct TreeNode* node = stack[--top];
        count++;
        if(node ->left) stack[top++] = node ->left;
        if(node ->right) stack[top++] = node ->right;
    }
    return count;
}
```

```c
//è¿­ä»£ï¼Œé˜Ÿåˆ—
int countNodes(struct TreeNode* root){
    int count=0;
    if(root == NULL) return count;
    struct TreeNode * queue[50000];
    int front=0,rear=0;
    queue[rear++] = root;
    count++;

    while(front != rear){
        int size= rear -front;
        for(int i=0;i<size;i++){
            struct TreeNode * node = queue[front++];
            if(node -> left) {
                queue[rear++] = node -> left;
                count++;
            }
            if(node -> right) {
                queue[rear++] = node -> right;
                count++;
            }
        }
    }
    return count;
}
```

### 4ã€å®Œå…¨äºŒå‰æ ‘æ€§è´¨è§£æ³•

* è¿™é“é¢˜ç»™æˆ‘ä»¬çš„å°±æ˜¯å®Œå…¨äºŒå‰æ ‘ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åˆ©ç”¨å®Œå…¨äºŒå‰æ ‘çš„æ€§è´¨æ¥è§£

* å®Œå…¨äºŒå‰æ ‘åªæœ‰ä¸¤ç§æƒ…å†µï¼Œæƒ…å†µä¸€ï¼šå°±æ˜¯æ»¡äºŒå‰æ ‘ï¼Œæƒ…å†µäºŒï¼šæœ€åä¸€å±‚å¶å­èŠ‚ç‚¹æ²¡æœ‰æ»¡ã€‚
  * å¯¹äºæƒ…å†µä¸€ï¼Œå¯ä»¥ç›´æ¥ç”¨ 2^æ ‘æ·±åº¦ - 1 æ¥è®¡ç®—ï¼Œæ³¨æ„è¿™é‡Œæ ¹èŠ‚ç‚¹æ·±åº¦ä¸º1ã€‚
  * å¯¹äºæƒ…å†µäºŒï¼Œåˆ†åˆ«é€’å½’å·¦å­©å­ï¼Œå’Œå³å­©å­ï¼Œé€’å½’åˆ°æŸä¸€æ·±åº¦ä¸€å®šä¼šæœ‰å·¦å­©å­æˆ–è€…å³å­©å­ä¸ºæ»¡äºŒå‰æ ‘ï¼Œç„¶åä¾ç„¶å¯ä»¥æŒ‰ç…§æƒ…å†µ1æ¥è®¡ç®—ã€‚
* å®Œå…¨äºŒå‰æ ‘ï¼ˆä¸€ï¼‰å¦‚å›¾ï¼š

![222.å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124092543662.png)

* å®Œå…¨äºŒå‰æ ‘ï¼ˆäºŒï¼‰å¦‚å›¾ï¼š
* ![222.å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124092634138.png)
* å¯ä»¥çœ‹å‡ºå¦‚æœæ•´ä¸ªæ ‘ä¸æ˜¯æ»¡äºŒå‰æ ‘ï¼Œå°±é€’å½’å…¶å·¦å³å­©å­ï¼Œç›´åˆ°é‡åˆ°æ»¡äºŒå‰æ ‘ä¸ºæ­¢ï¼Œç”¨å…¬å¼è®¡ç®—è¿™ä¸ªå­æ ‘ï¼ˆæ»¡äºŒå‰æ ‘ï¼‰çš„èŠ‚ç‚¹æ•°é‡ã€‚
* è¿™é‡Œå…³é”®åœ¨äºå¦‚ä½•å»åˆ¤æ–­ä¸€ä¸ªå·¦å­æ ‘æˆ–è€…å³å­æ ‘æ˜¯ä¸æ˜¯æ»¡äºŒå‰æ ‘å‘¢ï¼Ÿ
* åœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œå¦‚æœé€’å½’å‘å·¦éå†çš„æ·±åº¦ç­‰äºé€’å½’å‘å³éå†çš„æ·±åº¦ï¼Œé‚£è¯´æ˜å°±æ˜¯æ»¡äºŒå‰æ ‘ã€‚å¦‚å›¾ï¼š

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163554.png)

* æ³¨æ„ï¼šä¸‹å›¾è™½ç„¶é€’å½’å‘å·¦éå†çš„æ·±åº¦å’Œå‘å³æ·±åº¦ç›¸åŒï¼Œä½†å¹¶ä¸æ˜¯æ»¡äºŒå‰æ ‘ï¼Œå› ä¸ºå®ƒç”šè‡³ä¸æ˜¯å®Œå…¨äºŒå‰æ ‘ï¼Œæœ¬é¢˜ç»™æˆ‘ä»¬çš„æ ‘æœ¬èº«å°±æ˜¯å®Œå…¨äºŒå‰æ ‘ï¼Œæ‰€ä»¥æˆ‘ä»¬æ‰å¯ä»¥ä½¿ç”¨è¿™ç§åˆ¤æ–­å·¦å³æ·±åº¦çš„æ–¹æ³•æ¥è§£é¢˜
* ![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163811.png)

```c
//å®Œå…¨äºŒå‰æ ‘æ€§è´¨
int countNodes(struct TreeNode* root){
    //é€’å½’ç»ˆæ­¢æ¡ä»¶
    if(root==NULL)
        return 0;
    int leftDepth = 0;
    int rightDepth = 0;

    struct TreeNode* leftnode =root ->left;
    struct TreeNode* rightnode =root ->right;

    //æ±‚å‡ºå·¦å­æ ‘æ·±åº¦
    while(leftnode){
        leftnode = leftnode ->left;
        leftDepth++;
    }
    //æ±‚å‡ºå³å­æ ‘æ·±åº¦
    while(rightnode){
        rightnode = rightnode ->right;
        rightDepth++;
    }

    //è‹¥å·¦å³å­æ ‘æ·±åº¦ç›¸åŒï¼Œä¸ºæ»¡äºŒå‰æ ‘ã€‚ç»“ç‚¹ä¸ªæ•°ä¸º 2^height-1
    if(rightDepth == leftDepth){
        if(leftDepth == 0)
        //ç”¨å·¦ç§»æ¥è®¡ç®—å¹³æ–¹
            return (2 << leftDepth) -1;
    }
    //å¦åˆ™è¿”å›å·¦å³å­æ ‘çš„ç»“ç‚¹ä¸ªæ•° +1
    return countNodes(root -> right) + countNodes(root -> left) + 1;
}

```

## åã€å¹³è¡¡äºŒå‰æ ‘

* [ä»£ç éšæƒ³å½• (programmercarl.com)](https://programmercarl.com/0110.å¹³è¡¡äºŒå‰æ ‘.html#é¢˜å¤–è¯)
* [110. å¹³è¡¡äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/balanced-binary-tree/submissions/)

### 1ã€é¢˜ç›®

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯é«˜åº¦å¹³è¡¡çš„äºŒå‰æ ‘ã€‚
>
> æœ¬é¢˜ä¸­ï¼Œä¸€æ£µé«˜åº¦å¹³è¡¡äºŒå‰æ ‘å®šä¹‰ä¸ºï¼š
>
> ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹ çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 ã€‚
>
>  ![img](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> 
> è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
> è¾“å‡ºï¼štrue
> ```
>
> ![img](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)
>
> ```c
> ç¤ºä¾‹ 2ï¼š
> 
> è¾“å…¥ï¼šroot = [1,2,2,3,3,null,null,4,4]
> è¾“å‡ºï¼šfalse
> ```
>
> ```c
> ç¤ºä¾‹ 3ï¼š
> è¾“å…¥ï¼šroot = []
> è¾“å‡ºï¼štrue
> ```
>
>
> æç¤ºï¼š
>
> æ ‘ä¸­çš„èŠ‚ç‚¹æ•°åœ¨èŒƒå›´ `[0, 5000]` å†…
> -104 <= `Node.val` <= 104

### 2ã€é€’å½’æ€è·¯

* æ³¨æ„ä¸€ä¸ªæ¦‚å¿µï¼š

  * **äºŒå‰æ ‘èŠ‚ç‚¹çš„æ·±åº¦**ï¼šæŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„æœ€é•¿ç®€å•è·¯å¾„è¾¹çš„æ¡æ•°ã€‚

    * æ±‚æ·±åº¦ä¸€èˆ¬ç”¨çš„ï¼ˆå‰åºéå†ï¼‰
    * æ±‚[äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://programmercarl.com/0104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦.html) è¿™é¢˜ç”¨ååºéå†æ˜¯å› ä¸ºï¼Œæˆ‘ä»¬è¿™æ±‚å¾—å°±ç›¸å½“äºæ˜¯æ±‚æ ¹èŠ‚ç‚¹çš„é«˜åº¦

    ```c
    class Solution {
    public:
        int result;
        void getDepth(TreeNode* node, int depth) {
            result = depth > result ? depth : result; // ä¸­
    
            if (node->left == NULL && node->right == NULL) return ;
    
            if (node->left) { // å·¦
                depth++;    // æ·±åº¦+1
                getDepth(node->left, depth);
                depth--;    // å›æº¯ï¼Œæ·±åº¦-1
            }
            if (node->right) { // å³
                depth++;    // æ·±åº¦+1
                getDepth(node->right, depth);
                depth--;    // å›æº¯ï¼Œæ·±åº¦-1
            }
            return ;
        }
        int maxDepth(TreeNode* root) {
            result = 0;
            if (root == NULL) return result;
            getDepth(root, 1);
            return result;
        }
    };
    ```

    

  * **äºŒå‰æ ‘èŠ‚ç‚¹çš„é«˜åº¦**ï¼šæŒ‡ä»è¯¥èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æœ€é•¿ç®€å•è·¯å¾„è¾¹çš„æ¡æ•°ã€‚

    * æ±‚é«˜åº¦ä¸€èˆ¬ç”¨ï¼ˆååºéå†ï¼‰

* ç»è¿‡ä¸Šé¢åˆ†æï¼Œæˆ‘ä»¬åˆ¤æ–­å‡ºè¿™é“é¢˜ä¹Ÿéœ€è¦ç”¨**ååºéå†**
  * ä¸»è¦çš„æ€è·¯å°±æ˜¯ï¼Œé€’å½’éå†æ¯ä¸ªèŠ‚ç‚¹ï¼Œè·å–å…¶**å·¦å³å­èŠ‚ç‚¹çš„é«˜åº¦**ï¼Œç„¶åè¿›è¡Œæ¯”è¾ƒï¼Œè¦æ˜¯ä¸æ»¡è¶³å¹³è¡¡äºŒå‰æ ‘çš„è§„åˆ™ï¼Œé‚£ä¹ˆå°±ä¸€ç›´è¿”å› -1ï¼Œå¦åˆ™è¿”å›æ ¹èŠ‚ç‚¹çš„é«˜åº¦

### 3ã€é€’å½’ä»£ç 

```c
int height(struct TreeNode * root){
    //é€’å½’ç»ˆæ­¢æ¡ä»¶
    if(root ==NULL) return 0;

    //é€’å½’å¤„ç†
    int left_h = height(root ->left);
    int right_h = height(root ->right);
    //é‡åˆ°ä¸€æ¬¡ä¸æ»¡è¶³åä¸€ç›´è¿”å› -1
    if(fabs(left_h - right_h) >1 || left_h == -1 ||right_h ==-1){
        return -1;
    }
    //è®¡ç®—é«˜åº¦
    else {
        int height = left_h > right_h ? left_h : right_h;
        return height +1;
    }
}

bool isBalanced(struct TreeNode* root){
    return height(root) > -1;
}
```

### 4ã€ è¿­ä»£æ€è·¯

* åœ¨[104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ (opens new window)](https://programmercarl.com/0104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦.html)ä¸­æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å±‚åºéå†æ¥æ±‚æ·±åº¦ï¼Œä½†æ˜¯å°±ä¸èƒ½ç›´æ¥ç”¨å±‚åºéå†æ¥æ±‚é«˜åº¦äº†ï¼Œè¿™å°±ä½“ç°å‡ºæ±‚é«˜åº¦å’Œæ±‚æ·±åº¦çš„ä¸åŒã€‚
* æœ¬é¢˜çš„è¿­ä»£æ–¹å¼å¯ä»¥å…ˆå®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œä¸“é—¨ç”¨æ¥æ±‚é«˜åº¦ã€‚
* **è¿™ä¸ªå‡½æ•°é€šè¿‡æ ˆæ¨¡æ‹Ÿçš„ååºéå†æ‰¾æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„é«˜åº¦ï¼ˆå…¶å®æ˜¯é€šè¿‡æ±‚ä¼ å…¥èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æœ€å¤§æ·±åº¦æ¥æ±‚çš„é«˜åº¦ï¼‰**
* **ç„¶åå†ç”¨æ ˆæ¥æ¨¡æ‹Ÿååºéå†ï¼Œéå†æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™ï¼Œå†å»åˆ¤æ–­å·¦å³å­©å­çš„é«˜åº¦æ˜¯å¦ç¬¦åˆï¼Œä»£ç å¦‚ä¸‹ï¼š**

```c
//è®¡ç®—ç»“ç‚¹æ·±åº¦
int getDepth(struct TreeNode* node) {
    //å¼€è¾Ÿæ ˆç©ºé—´
    struct TreeNode** stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 10000);
    int stackTop = 0;
    //è‹¥ä¼ å…¥ç»“ç‚¹å­˜åœ¨ï¼Œå°†å…¶å…¥æ ˆã€‚è‹¥ä¸å­˜åœ¨ï¼Œå‡½æ•°ç›´æ¥è¿”å›0
    if(node)
        stack[stackTop++] = node;
    int result = 0;
    int depth = 0;

    //å½“æ ˆä¸­æœ‰å…ƒç´ æ—¶ï¼Œè¿›è¡Œè¿­ä»£éå†
    while(stackTop) {
        //å–å‡ºæ ˆé¡¶å…ƒç´ 
        struct TreeNode* tempNode = stack[--stackTop];
        //è‹¥æ ˆé¡¶å…ƒç´ éNULLï¼Œåˆ™å°†æ·±åº¦+1
        if(tempNode) {
            depth++;
            //å°†æ ˆé¡¶å…ƒç´ å†æ¬¡å…¥æ ˆï¼Œæ·»åŠ NULLè¡¨ç¤ºæ­¤ç»“ç‚¹å·²è¢«éå†
            stack[stackTop++] = tempNode;
            stack[stackTop++] = NULL;
            //è‹¥æ ˆé¡¶å…ƒç´ æœ‰å·¦å³å­©å­ï¼Œåˆ™å°†å­©å­ç»“ç‚¹å…¥æ ˆ
            if(tempNode->left)
                stack[stackTop++] = tempNode->left;
            if(tempNode->right)
                stack[stackTop++] = tempNode->right;
            //æ›´æ–°ç»“æœ
            result = result > depth ? result : depth;
        }
        else {
            //è‹¥ä¸ºNULLï¼Œåˆ™ä»£è¡¨å½“å‰ç»“ç‚¹å·²è¢«éå†ï¼Œæ·±åº¦-1
            tempNode = stack[--stackTop];
            depth--;
        }
    }

    return result;
}

bool isBalanced(struct TreeNode* root){
    //å¼€è¾Ÿæ ˆç©ºé—´
    struct TreeNode** stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 10000);
    int stackTop = 0;

    //è‹¥æ ¹èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œè¿”å›True
    if(!root)
        return 1;

    //å°†æ ¹èŠ‚ç‚¹å…¥æ ˆ
    stack[stackTop++] = root;
    //å½“æ ˆä¸­æœ‰å…ƒç´ æ—¶ï¼Œè¿›è¡Œéå†
    while(stackTop) {
        //å°†æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
        struct TreeNode* node = stack[--stackTop];
        //è®¡ç®—å·¦å³å­æ ‘çš„æ·±åº¦
        int diff = getDepth(node->right) - getDepth(node->left);
        //è‹¥æ·±åº¦çš„ç»å¯¹å€¼å¤§äº1ï¼Œè¿”å›False
        if(diff > 1 || diff < -1)
            return 0;
        //å¦‚æœæ ˆé¡¶ç»“ç‚¹æœ‰å·¦å³ç»“ç‚¹ï¼Œå°†å·¦å³ç»“ç‚¹å…¥æ ˆ
        if(node->left)
            stack[stackTop++] = node->left;
        if(node->right)
            stack[stackTop++] = node->right;
    }
    //è‹¥äºŒå‰æ ‘éå†ç»“æŸåæ²¡æœ‰è¿”å›Falseï¼Œåˆ™è¿”å›True
    return 1;
}
```

## åä¸€ã€äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„

[257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-paths/)

### 1ã€é¢˜ç›®

> * ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼ŒæŒ‰ ä»»æ„é¡ºåº ï¼Œè¿”å›æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚
> * å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
>
> ![img](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> è¾“å…¥ï¼šroot = [1,2,3,null,5]
> è¾“å‡ºï¼š["1->2->5","1->3"]
> ```
>
> ```
> ç¤ºä¾‹ 2ï¼š
> è¾“å…¥ï¼šroot = [1]
> è¾“å‡ºï¼š["1"]
> ```
>
>
> æç¤ºï¼š
>
> æ ‘ä¸­èŠ‚ç‚¹çš„æ•°ç›®åœ¨èŒƒå›´ **[1, 100]** å†…
> -100 <= **Node.val** <= 100
>
> ```c
> /**
>  * Definition for a binary tree node.
>  * struct TreeNode {
>  *     int val;
>  *     struct TreeNode *left;
>  *     struct TreeNode *right;
>  * };
>  */
> 
> /**
>  * Note: The returned array must be malloced, assume caller calls free().
>  */
> ```
>
> 

### 2ã€é€’å½’å†™æ³•

* 1ã€åˆ›å»ºä¸€ä¸ªæ•°ç»„æ¥ä¿å­˜æ¯å±‚éå†åˆ°çš„ç»“ç‚¹çš„å€¼
* 2ã€é€’å½’å‡½æ•°
  * å½“é€’å½’åˆ°å¶å­èŠ‚ç‚¹æ—¶ï¼Œè¿›è¡Œå­—ç¬¦ä¸²å¤„ç†
  * å¦‚æœä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œå°±å°†å½“å‰èŠ‚ç‚¹çš„å€¼ä¿å­˜è¿›æ•°ç»„é‡Œï¼Œç„¶åç»§ç»­é€’å½’

```c
void construct_paths(struct TreeNode*root,char **paths,int* returnSize,int*sta,int top){
    if(root != NULL){
        if(root->left ==NULL && root ->right == NULL){ //å½“å‰èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹
            char* tmp =(char*)malloc(1001);
            int len =0;
            for(int i=0;i<top;i++){
                //sprintf ä¼šè¿”å›å†™å…¥çš„å­—ç¬¦æ•°
                //temæ˜¯charæŒ‡é’ˆï¼Œæ¯æ¬¡ +1ï¼Œéƒ½æ˜¯tmpä¸­å­˜å‚¨çš„åœ°å€å€¼å°± +1
                len+=sprintf(tmp + len, "%d->",sta[i]);
            } 
              //æœ€åä¸€ä¸ªéœ€è¦å•ç‹¬å¤„ç†
            sprintf(tmp+len,"%d",root ->val);
            paths[(*returnSize)++] =tmp;
        }
        else{
            sta[top++]=root->val; //å½“å‰èŠ‚ç‚¹ä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œç»§ç»­é€’å½’éå†
            construct_paths(root->left,paths,returnSize,sta,top);
            construct_paths(root->right,paths,returnSize,sta,top);
        }
    }
}

char ** binaryTreePaths(struct TreeNode* root, int* returnSize){
    char ** paths = (char**)malloc(sizeof(char*) * 1001);
    * returnSize =0;
    //ç”¨æ¥ä¸´æ—¶å­˜å‚¨ç»“ç‚¹
    int sta[1001];
    //ä¸‹é¢ä¼ å…¥ returnSize æ˜¯ä¼ å…¥åœ°å€ï¼Œ*returnSizeæ˜¯è§£å¼•ç”¨çš„æ„æ€
    construct_paths(root,paths,returnSize,sta,0);
    return paths;
}
```

### 3ã€è¿­ä»£å†™æ³•

```c
char** binaryTreePaths(struct TreeNode* root, int* returnSize) {
    char** paths = (char**)malloc(sizeof(char*) * 1001);
    *returnSize = 0;
    if (root == NULL) {
        return paths;
    }

    struct TreeNode** node_queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 1001);
    char** path_queue = (char**)malloc(sizeof(char*) * 1001);

    int left = 0, right = 0;

    char* tmp = malloc(sizeof(char) * 1001);
    sprintf(tmp, "%d", root->val);
    node_queue[right] = root;
    path_queue[right++] = tmp;

    while (left < right) {
        struct TreeNode* node = node_queue[left];
        char* path = path_queue[left++];

        if (node->left == NULL && node->right == NULL) {
            paths[(*returnSize)++] = path;
        } else {
            int n = strlen(path);
            if (node->left != NULL) {
                char* tmp = malloc(sizeof(char) * 1001);
                for (int i = 0; i < n; i++) {
                    tmp[i] = path[i];
                }
                sprintf(tmp + n, "->%d", node->left->val);
                node_queue[right] = node->left;
                path_queue[right++] = tmp;
            }

            if (node->right != NULL) {
                char* tmp = malloc(sizeof(char) * 1001);
                for (int i = 0; i < n; i++) {
                    tmp[i] = path[i];
                }
                sprintf(tmp + n, "->%d", node->right->val);
                node_queue[right] = node->right;
                path_queue[right++] = tmp;
            }
        }
    }
    return paths;
}

```



## åäºŒã€å·¦å¶å­ä¹‹å’Œ

[404. å·¦å¶å­ä¹‹å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/sum-of-left-leaves/)

[ä»£ç éšæƒ³å½• (programmercarl.com)](https://www.programmercarl.com/0404.å·¦å¶å­ä¹‹å’Œ.html#è§†é¢‘è®²è§£)

### 1ã€é¢˜ç›®

> * ç»™å®šäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›æ‰€æœ‰å·¦å¶å­ä¹‹å’Œã€‚
>
> ![img](https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg)
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> è¾“å…¥: root = [3,9,20,null,null,15,7] 
> è¾“å‡º: 24 
> è§£é‡Š: åœ¨è¿™ä¸ªäºŒå‰æ ‘ä¸­ï¼Œæœ‰ä¸¤ä¸ªå·¦å¶å­ï¼Œåˆ†åˆ«æ˜¯ 9 å’Œ 15ï¼Œæ‰€ä»¥è¿”å› 24
> ```
>
> ```c
> ç¤ºä¾‹ 2:
> è¾“å…¥: root = [1]
> è¾“å‡º: 0
> ```
>
> **æç¤º:**
>
> - èŠ‚ç‚¹æ•°åœ¨ `[1, 1000]` èŒƒå›´å†…
> - `-1000 <= Node.val <= 1000`

### 2ã€ä»€ä¹ˆæ˜¯å·¦å¶å­

* **é¦–å…ˆè¦æ³¨æ„æ˜¯åˆ¤æ–­å·¦å¶å­ï¼Œä¸æ˜¯äºŒå‰æ ‘å·¦ä¾§èŠ‚ç‚¹ï¼Œæ‰€ä»¥ä¸è¦ä¸Šæ¥æƒ³ç€å±‚åºéå†ã€‚**
  * å› ä¸ºé¢˜ç›®ä¸­å…¶å®æ²¡æœ‰è¯´æ¸…æ¥šå·¦å¶å­ç©¶ç«Ÿæ˜¯ä»€ä¹ˆèŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘æ¥ç»™å‡ºå·¦å¶å­çš„æ˜ç¡®å®šä¹‰ï¼š**èŠ‚ç‚¹Açš„å·¦å­©å­ä¸ä¸ºç©ºï¼Œä¸”å·¦å­©å­çš„å·¦å³å­©å­éƒ½ä¸ºç©ºï¼ˆè¯´æ˜æ˜¯å¶å­èŠ‚ç‚¹ï¼‰ï¼Œé‚£ä¹ˆAèŠ‚ç‚¹çš„å·¦å­©å­ä¸ºå·¦å¶å­èŠ‚ç‚¹**

* å¤§å®¶æ€è€ƒä¸€ä¸‹å¦‚ä¸‹å›¾ä¸­äºŒå‰æ ‘ï¼Œå·¦å¶å­ä¹‹å’Œç©¶ç«Ÿæ˜¯å¤šå°‘ï¼Ÿ

![404.å·¦å¶å­ä¹‹å’Œ](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204151949672.png) 

* **å…¶å®æ˜¯0ï¼Œå› ä¸ºè¿™æ£µæ ‘æ ¹æœ¬æ²¡æœ‰å·¦å¶å­ï¼**

* ä½†çœ‹è¿™ä¸ªå›¾çš„å·¦å¶å­ä¹‹å’Œæ˜¯å¤šå°‘ï¼Ÿ

![å›¾äºŒ](https://code-thinking-1253855093.file.myqcloud.com/pics/20220902165805.png)

* æ‰€ä»¥**åˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯ä¸æ˜¯å·¦å¶å­æ˜¯æ— æ³•åˆ¤æ–­çš„ï¼Œå¿…é¡»è¦é€šè¿‡èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹æ¥åˆ¤æ–­å…¶å·¦å­©å­æ˜¯ä¸æ˜¯å·¦å¶å­ã€‚**

* å¦‚æœè¯¥èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œè¯¥èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ä¸ºç©ºï¼Œè¯¥èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ä¸ºç©ºï¼Œåˆ™æ‰¾åˆ°äº†ä¸€ä¸ªå·¦å¶å­ï¼Œåˆ¤æ–­ä»£ç å¦‚ä¸‹ï¼š

```cpp
if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
    å·¦å¶å­èŠ‚ç‚¹å¤„ç†é€»è¾‘
}
```

### 3ã€é€’å½’å†™æ³•

* é€’å½’çš„éå†é¡ºåºä¸ºååºéå†ï¼ˆå·¦å³ä¸­ï¼‰ï¼Œæ˜¯å› ä¸ºè¦é€šè¿‡é€’å½’å‡½æ•°çš„è¿”å›å€¼æ¥ç´¯åŠ æ±‚å–å·¦å¶å­æ•°å€¼ä¹‹å’Œã€‚

* é€’å½’ä¸‰éƒ¨æ›²ï¼š

  1. #### ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼

* åˆ¤æ–­ä¸€ä¸ªæ ‘çš„å·¦å¶å­èŠ‚ç‚¹ä¹‹å’Œï¼Œé‚£ä¹ˆä¸€å®šè¦ä¼ å…¥æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œé€’å½’å‡½æ•°çš„è¿”å›å€¼ä¸ºæ•°å€¼ä¹‹å’Œï¼Œæ‰€ä»¥ä¸ºint

* ä½¿ç”¨é¢˜ç›®ä¸­ç»™å‡ºçš„å‡½æ•°å°±å¯ä»¥äº†ã€‚

  2. #### ç¡®å®šç»ˆæ­¢æ¡ä»¶

* å¦‚æœéå†åˆ°ç©ºèŠ‚ç‚¹ï¼Œé‚£ä¹ˆå·¦å¶å­å€¼ä¸€å®šæ˜¯0

```cpp
if (root == NULL) return 0;
```

* æ³¨æ„ï¼Œ**åªæœ‰å½“å‰éå†çš„èŠ‚ç‚¹æ˜¯çˆ¶èŠ‚ç‚¹ï¼Œæ‰èƒ½åˆ¤æ–­å…¶å­èŠ‚ç‚¹æ˜¯ä¸æ˜¯å·¦å¶å­ã€‚ æ‰€ä»¥å¦‚æœå½“å‰éå†çš„èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹ï¼Œé‚£å…¶å·¦å¶å­ä¹Ÿå¿…å®šæ˜¯0**ï¼Œé‚£ä¹ˆç»ˆæ­¢æ¡ä»¶ä¸ºï¼š

```cpp
if (root == NULL) return 0;
if (root->left == NULL && root->right== NULL) return 0; //å…¶å®è¿™ä¸ªä¹Ÿå¯ä»¥ä¸å†™ï¼Œå¦‚æœä¸å†™ä¸å½±å“ç»“æœï¼Œä½†å°±ä¼šè®©é€’å½’å¤šè¿›è¡Œäº†ä¸€å±‚ã€‚
```

* #### 	3. ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘

* **å½“é‡åˆ°å·¦å¶å­èŠ‚ç‚¹çš„æ—¶å€™ï¼Œè®°å½•æ•°å€¼ï¼Œç„¶åé€šè¿‡é€’å½’æ±‚å–å·¦å­æ ‘å·¦å¶å­ä¹‹å’Œï¼Œå’Œå³å­æ ‘å·¦å¶å­ä¹‹å’Œï¼Œç›¸åŠ ä¾¿æ˜¯æ•´ä¸ªæ ‘çš„å·¦å¶å­ä¹‹å’Œ**ã€‚

* ä»£ç å¦‚ä¸‹ï¼š

```cpp
int leftValue = sumOfLeftLeaves(root->left);    // å·¦
if (root->left && !root->left->left && !root->left->right) {
    leftValue = root->left->val;
}
int rightValue = sumOfLeftLeaves(root->right);  // å³

int sum = leftValue + rightValue;               // ä¸­
return sum;
```

* æ•´ä½“é€’å½’ä»£ç å¦‚ä¸‹ï¼š

```c
int sumOfLeftLeaves(struct TreeNode* root){

  //é€’å½’ç»ˆæ­¢æ¡ä»¶
  if(root == NULL) return 0;
  if(root->left==NULL && root ->right ==NULL) return 0;
  //é€’å½’å¤„ç†
  int leftValue = sumOfLeftLeaves(root->left); //å·¦

  if(root->left != NULL && root->left->left ==NULL && root->left->right ==NULL)
  // å·¦å­æ ‘å°±æ˜¯ä¸€ä¸ªå·¦å¶å­çš„æƒ…å†µ
  {
      leftValue= root->left->val;
  }
  int rightValue = sumOfLeftLeaves(root->right); //å³
  int sum = leftValue + rightValue; //ä¸­

    return sum;
}
```

* ä»¥ä¸Šä»£ç ç²¾ç®€ä¹‹åå¦‚ä¸‹ï¼š

```c
int sumOfLeftLeaves(struct TreeNode* root){

  //é€’å½’ç»ˆæ­¢æ¡ä»¶
  if(root == NULL) return 0;
  if(root->left==NULL && root ->right ==NULL) return 0;
  int leftValue=0;
  if(root->left != NULL && root->left->left ==NULL && root->left->right ==NULL)
  {
    leftValue= root->left->val;
  }

    return leftValue + sumOfLeftLeaves(root->left)+sumOfLeftLeaves(root->right);
}
```

* ç²¾ç®€ä¹‹åçš„ä»£ç å…¶å®çœ‹ä¸å‡ºæ¥ç”¨çš„æ˜¯ä»€ä¹ˆéå†æ–¹å¼äº†ï¼Œå¯¹äºç®—æ³•åˆå­¦è€…ä»¥ä¸Šæ ¹æ®ç¬¬ä¸€ä¸ªç‰ˆæœ¬æ¥å­¦ä¹ ã€‚

### 4ã€è¿­ä»£å†™æ³•

#### 4.1 å±‚åºéå†

```c
int sumOfLeftLeaves(struct TreeNode* root){
    int sum =0;
    if(root==NULL) return sum;
    struct TreeNode* queue[2000]; //å¤§å°ç»™å¤§ç‚¹ğŸ˜‚ï¼Œä¸ç„¶æµ‹è¯•ä»£ç ä¸é€šè¿‡
    int front=0,rear=0;
    queue[rear++] =  root;

    while(front != rear){
        int size = rear- front;
        for(int i=0 ;i<size;i++){
            struct TreeNode* node = queue[front++];
            //åˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯å¦æœ‰å·¦å¶å­èŠ‚ç‚¹
            if(node->left!=NULL&& node->left->left == NULL && node ->left ->right ==NULL){
                sum+= node->left->val;
            }

            if(node->left) queue[rear++] = node ->left;
            if(node->right) queue[rear++] = node ->right;
        }
    }

    return sum;
}
```



#### 4.2 æ·±åº¦éå†

```c
//ä»¥ä¸‹æ˜¯ååºéå†çš„å†™æ³•ï¼Œæ³¨æ„æˆ‘ä»¬æ˜¯çœ‹å¤„ç†èŠ‚ç‚¹çš„é¡ºåºé‡Œåˆ¤æ–­æ˜¯è¯´æ˜éå†é¡ºåºçš„
int sumOfLeftLeaves(struct TreeNode* root){
    int sum =0;
    if(root==NULL) return sum;
    struct TreeNode* stack[2000]; //å¤§å°ç»™å¤§ç‚¹ğŸ˜‚ï¼Œä¸ç„¶æµ‹è¯•ä»£ç ä¸é€šè¿‡
    int top=0;
    stack[top++] = root;

    while(top>0){
        struct TreeNode* node = stack[top-1];
        if(node != NULL){
            top--;                   
            stack[top++] = node;   //ä¸­
            stack[top++]= NULL;
            if(node ->right) stack[top++] = node->right;   //å³
             if(node ->left) stack[top++] = node->left;    //å·¦
        }
        else {
            top--; //å¼¹å‡ºNULL
            node = stack[--top];//è·å–è¦å¤„ç†çš„èŠ‚ç‚¹
            if(node->left!=NULL&& node->left->left == NULL && node ->left ->right ==NULL){
                sum+= node->left->val;
            }
        }
    }
    return sum;

}
```

## åä¸‰ã€æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼

[513. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/find-bottom-left-tree-value/)

### 1ã€é¢˜ç›®

> * ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„ æ ¹èŠ‚ç‚¹ rootï¼Œè¯·æ‰¾å‡ºè¯¥äºŒå‰æ ‘çš„ æœ€åº•å±‚ æœ€å·¦è¾¹ èŠ‚ç‚¹çš„å€¼ã€‚
> * å‡è®¾äºŒå‰æ ‘ä¸­è‡³å°‘æœ‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚
>
>  ![img](https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg)
>
> ```c
> ç¤ºä¾‹ 1:
> è¾“å…¥: root = [2,1,3]
> è¾“å‡º: 1
> ```
>
> ![img](https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg)
>
> ```c
> ç¤ºä¾‹ 2:
> è¾“å…¥: [1,2,3,4,null,5,6,null,null,7]
> è¾“å‡º: 7
> ```
>
> æç¤º:
>
> äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°çš„èŒƒå›´æ˜¯ **[1,10^4]**
> `-2^31 <= Node.val <= 2^31 - 1` 



### 2ã€é€’å½’æ€è·¯åŠå†™æ³•

* é€’å½’è·å–æ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦ï¼Œåˆ¤æ–­èŠ‚ç‚¹çš„æ·±åº¦ï¼Œé‡åˆ°æ·±åº¦æ›´æ·±çš„å°±è®°å½•è¯¥å€¼ï¼Œæ³¨æ„æˆ‘ä»¬ä¸‹é¢ç”¨çš„å‰åºéå†ï¼Œï¼ˆä¸­åºéå†åº”è¯¥å¯ä»¥ï¼‰ï¼Œååºéå†å°±ä¸å¯ä»¥ï¼Œå› ä¸ºç›¸åŒæ·±åº¦çš„èŠ‚ç‚¹æˆ‘ä»¬åªè®°å½•ç¬¬ä¸€ä¸ªçš„å€¼ï¼Œ(å³æœ€å·¦)ï¼Œæ‰€ä»¥è¦å…ˆéå†å·¦èŠ‚ç‚¹

```C
 //é€’å½’å†™æ³•
void traversal(struct TreeNode * root,int depth , int *maxDepth ,int*result){
    if(root->left ==NULL && root -> right ==NULL){   //ä¸­
        //é‡åˆ°æ·±åº¦æ›´æ·±çš„å¶å­èŠ‚ç‚¹å°±è®°å½•è¯¥èŠ‚ç‚¹çš„å€¼
        if(depth > *maxDepth){
            *maxDepth =depth;
            *result =root->val;
        }
    }
    //æˆ‘ä»¬è¦è·å–çš„æ˜¯æœ€åº•æœ€å·¦çš„èŠ‚ç‚¹å€¼ï¼Œæ‰€ä»¥åº”è¯¥å…ˆè¿›å·¦èŠ‚ç‚¹
    if(root->left){                                   //å·¦
        depth++;
        traversal(root->left,depth,maxDepth,result);
        depth--;
    }
    if(root->right){                                  //å³
        depth++;
        traversal(root->right,depth,maxDepth,result);
        depth--;
    }
    return ;
}

int findBottomLeftValue(struct TreeNode* root){
    int maxDepth = INT_MIN; 
    int result = 0;
    //leetcode cå¥½åƒä¸æ”¯æŒç”¨å…¨å±€å˜é‡ï¼Œæ‰§è¡Œæ¡ˆä¾‹ä¼šæˆåŠŸï¼Œä½†æ˜¯æäº¤ä»£ç å°±ä¼šå¤±è´¥
    //æ‰€ä»¥è¿™é‡Œä½¿ç”¨æŒ‡é’ˆæ¥æ“ä½œå˜é‡å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦ä¼ å…¥åœ°å€
    traversal(root,0,&maxDepth,&result);
    return result;

}
```

### 3ã€å±‚åºéå†

* è¿™ä¸ªé¢˜çš„å±‚åºéå†æ¯”è¾ƒç®€å•
* å°±æ­£å¸¸å±‚åºéå†èŠ‚ç‚¹ï¼Œæ³¨æ„æˆ‘ä»¬è¿™é‡Œå±‚åºéå†å…ˆè¿›å³èŠ‚ç‚¹ï¼Œå†è¿›å·¦èŠ‚ç‚¹å°±å¯ä»¥ä¿è¯æˆ‘ä»¬æƒ³è¦çš„å€¼æ˜¯æœ€åè¿›å…¥é˜Ÿåˆ—çš„

```c
 //å±‚åºéå†å†™æ³•
int findBottomLeftValue(struct TreeNode* root){
    int result = 0;
    if(root==NULL) {
        return result=root->val;
    }

    struct TreeNode* queue[10000];
    int front=0,rear=0;
    queue[rear++] = root;

    while(front != rear){
        int size = rear - front;
        for(int i=0;i<size;i++){
            struct TreeNode* node = queue[front++];  
            //å› ä¸ºæˆ‘ä»¬è¦çš„æ˜¯æœ€æ·±å±‚æœ€å·¦è¾¹çš„èŠ‚ç‚¹å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬ä»å³èŠ‚ç‚¹å…ˆè¿›ï¼Œå°±å¯ä»¥ä¿è¯æˆ‘ä»¬æƒ³è¦çš„å€¼æ˜¯æœ€åè¿›å…¥é˜Ÿåˆ—çš„
            if(node->right) queue[rear++] = node ->right;
            if(node->left) queue[rear++] = node ->left;
            
        }
        if(front == rear) {
            result = queue[front-1] ->val;
        }
    }
    return result;
}
```

## åå››ã€è·¯å¾„æ€»å’Œ

[112. è·¯å¾„æ€»å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/path-sum/)

[ä»£ç éšæƒ³å½• (programmercarl.com)](https://www.programmercarl.com/0112.è·¯å¾„æ€»å’Œ.html)

### 1ã€é¢˜ç›®

> ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` å’Œä¸€ä¸ªè¡¨ç¤ºç›®æ ‡å’Œçš„æ•´æ•° `targetSum` ã€‚åˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨ **æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹** çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’Œ `targetSum` ã€‚å¦‚æœå­˜åœ¨ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚
>
> **å¶å­èŠ‚ç‚¹** æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
>
>  ![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> è¾“å…¥ï¼šroot = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
> è¾“å‡ºï¼štrue
> è§£é‡Šï¼šç­‰äºç›®æ ‡å’Œçš„æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹è·¯å¾„å¦‚ä¸Šå›¾æ‰€ç¤ºã€‚
> ```
>
> ![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)
>
> ```c
> ç¤ºä¾‹2ï¼š
> è¾“å…¥ï¼šroot = [1,2,3], targetSum = 5
> è¾“å‡ºï¼šfalse
> è§£é‡Šï¼šæ ‘ä¸­å­˜åœ¨ä¸¤æ¡æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼š
> (1 --> 2): å’Œä¸º 3
> (1 --> 3): å’Œä¸º 4
> ä¸å­˜åœ¨ sum = 5 çš„æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚
> ```
>
> ```c
> ç¤ºä¾‹ 3ï¼š
> è¾“å…¥ï¼šroot = [], targetSum = 0
> è¾“å‡ºï¼šfalse
> è§£é‡Šï¼šç”±äºæ ‘æ˜¯ç©ºçš„ï¼Œæ‰€ä»¥ä¸å­˜åœ¨æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚
> ```



### 2ã€é€’å½’æ€è·¯åŠå†™æ³•

![112.è·¯å¾„æ€»å’Œ](https://code-thinking-1253855093.file.myqcloud.com/pics/2021020316051216.png)

1. ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›ç±»å‹

* å›¾ä¸­å¯ä»¥çœ‹å‡ºï¼Œéå†çš„è·¯çº¿ï¼Œå¹¶ä¸è¦éå†æ•´æ£µæ ‘ï¼Œæ‰€ä»¥é€’å½’å‡½æ•°éœ€è¦è¿”å›å€¼ï¼Œå¯ä»¥ç”¨boolç±»å‹è¡¨ç¤ºã€‚

* æ‰€ä»¥ä»£ç å¦‚ä¸‹ï¼š

```cpp
bool traversal(treenode* cur, int count)   // æ³¨æ„å‡½æ•°çš„è¿”å›ç±»å‹
```

2. ç¡®å®šç»ˆæ­¢æ¡ä»¶

* é¦–å…ˆè®¡æ•°å™¨å¦‚ä½•ç»Ÿè®¡è¿™ä¸€æ¡è·¯å¾„çš„å’Œå‘¢ï¼Ÿ

* ä¸è¦å»ç´¯åŠ ç„¶ååˆ¤æ–­æ˜¯å¦ç­‰äºç›®æ ‡å’Œï¼Œé‚£ä¹ˆä»£ç æ¯”è¾ƒéº»çƒ¦ï¼Œå¯ä»¥ç”¨é€’å‡ï¼Œè®©è®¡æ•°å™¨countåˆå§‹ä¸ºç›®æ ‡å’Œï¼Œç„¶åæ¯æ¬¡å‡å»éå†è·¯å¾„èŠ‚ç‚¹ä¸Šçš„æ•°å€¼ã€‚

* å¦‚æœæœ€åcount == 0ï¼ŒåŒæ—¶åˆ°äº†å¶å­èŠ‚ç‚¹çš„è¯ï¼Œè¯´æ˜æ‰¾åˆ°äº†ç›®æ ‡å’Œã€‚

* å¦‚æœéå†åˆ°äº†å¶å­èŠ‚ç‚¹ï¼Œcountä¸ä¸º0ï¼Œå°±æ˜¯æ²¡æ‰¾åˆ°ã€‚

* é€’å½’ç»ˆæ­¢æ¡ä»¶ä»£ç å¦‚ä¸‹ï¼š

```cpp
if (!cur->left && !cur->right && count == 0) return true; // é‡åˆ°å¶å­èŠ‚ç‚¹ï¼Œå¹¶ä¸”è®¡æ•°ä¸º0
if (!cur->left && !cur->right) return false; // é‡åˆ°å¶å­èŠ‚ç‚¹è€Œæ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„è¾¹ï¼Œç›´æ¥è¿”å›
```

3. ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘

* å› ä¸ºç»ˆæ­¢æ¡ä»¶æ˜¯åˆ¤æ–­å¶å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥é€’å½’çš„è¿‡ç¨‹ä¸­å°±ä¸è¦è®©ç©ºèŠ‚ç‚¹è¿›å…¥é€’å½’äº†ã€‚

* é€’å½’å‡½æ•°æ˜¯æœ‰è¿”å›å€¼çš„ï¼Œå¦‚æœé€’å½’å‡½æ•°è¿”å›trueï¼Œè¯´æ˜æ‰¾åˆ°äº†åˆé€‚çš„è·¯å¾„ï¼Œåº”è¯¥ç«‹åˆ»è¿”å›ã€‚

* ä»£ç å¦‚ä¸‹ï¼š

```cpp
if (cur->left) { // å·¦ ï¼ˆç©ºèŠ‚ç‚¹ä¸éå†ï¼‰
    // é‡åˆ°å¶å­èŠ‚ç‚¹è¿”å›trueï¼Œåˆ™ç›´æ¥è¿”å›true
    if (traversal(cur->left, count - cur->left->val)) return true; // æ³¨æ„è¿™é‡Œæœ‰å›æº¯çš„é€»è¾‘
}
if (cur->right) { // å³ ï¼ˆç©ºèŠ‚ç‚¹ä¸éå†ï¼‰
    // é‡åˆ°å¶å­èŠ‚ç‚¹è¿”å›trueï¼Œåˆ™ç›´æ¥è¿”å›true
    if (traversal(cur->right, count - cur->right->val)) return true; // æ³¨æ„è¿™é‡Œæœ‰å›æº¯çš„é€»è¾‘
}
return false;
```

æ•´ä½“ä»£ç ï¼š

```cpp
class Solution {
private:
    bool traversal(TreeNode* cur, int count) {
        if (!cur->left && !cur->right && count == 0) return true; // é‡åˆ°å¶å­èŠ‚ç‚¹ï¼Œå¹¶ä¸”è®¡æ•°ä¸º0
        if (!cur->left && !cur->right) return false; // é‡åˆ°å¶å­èŠ‚ç‚¹ç›´æ¥è¿”å›

        if (cur->left) { // å·¦
            count -= cur->left->val; // é€’å½’ï¼Œå¤„ç†èŠ‚ç‚¹;
            if (traversal(cur->left, count)) return true;
            count += cur->left->val; // å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ
        }
        if (cur->right) { // å³
            count -= cur->right->val; // é€’å½’ï¼Œå¤„ç†èŠ‚ç‚¹;
            if (traversal(cur->right, count)) return true;
            count += cur->right->val; // å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ
        }
        return false;
    }

public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (root == NULL) return false;
        return traversal(root, sum - root->val);
    }
};
```

ç²¾ç®€å†™æ³•ï¼š

```c
bool hasPathSum(struct TreeNode* root, int targetSum){
    // é€’å½’ç»“æŸæ¡ä»¶ï¼šè‹¥å½“å‰èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œè¿”å›false
    if(!root)
        return false;
    // è‹¥å½“å‰èŠ‚ç‚¹ä¸ºå¶å­èŠ‚ç‚¹ï¼Œä¸”targetSum-rootçš„å€¼ä¸º0ã€‚ï¼ˆå½“å‰è·¯å¾„ä¸Šçš„èŠ‚ç‚¹å€¼çš„å’Œæ»¡è¶³æ¡ä»¶ï¼‰è¿”å›true
    if(!root->right && !root->left && targetSum == root->val)
        return true;

    // æŸ¥çœ‹å·¦å­æ ‘å’Œå³å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹æ˜¯å¦æ»¡è¶³æ¡ä»¶
    return hasPathSum(root->right, targetSum - root->val) || hasPathSum(root->left, targetSum - root->val);
}
```



### 3ã€è¿­ä»£æ€è·¯åŠå†™æ³•

* 1. æ„å»ºä¸€ä¸ªç»“æ„ä½“ Pairï¼Œç”¨æ¥å­˜æ”¾èŠ‚ç‚¹ï¼Œå’Œåˆ°è¾¾å¯¹åº”èŠ‚ç‚¹çš„è·¯å¾„å€¼

```c
// å­˜å‚¨ä¸€ä¸ªèŠ‚ç‚¹ä»¥åŠå½“å‰çš„å’Œ
struct Pair {
    struct TreeNode* node;
    int sum;
};
```

* 2. åˆ¤æ–­ï¼Œè‹¥æ ˆé¡¶å…ƒç´ ä¸ºå¶å­èŠ‚ç‚¹ï¼Œä¸”å’Œä¸ºtargetSumæ—¶ï¼Œè¿”å›true

```c
// è‹¥æ ˆé¡¶å…ƒç´ ä¸ºå¶å­èŠ‚ç‚¹ï¼Œä¸”å’Œä¸ºtargetSumæ—¶ï¼Œè¿”å›true
   if(!topPair.node->left && !topPair.node->right && topPair.sum == targetSum){
         return true;
    }
```

* è‹¥å½“å‰æ ˆé¡¶èŠ‚ç‚¹æœ‰å·¦å³å­©å­ï¼Œè®¡ç®—å’Œå¹¶å…¥æ ˆ

```c
if(topPair.node->left) {
     struct Pair newPair = {topPair.node->left, topPair.sum + topPair.node->left->val};
     stack[stackTop++] = newPair;
}
if(topPair.node->right) {
     struct Pair newPair = {topPair.node->right, topPair.sum + topPair.node->right->val};
     stack[stackTop++] = newPair;
}
```

æ•´ä½“ä»£ç ï¼š

```c
// å­˜å‚¨ä¸€ä¸ªèŠ‚ç‚¹ä»¥åŠå½“å‰çš„å’Œ
struct Pair {
    struct TreeNode* node;
    int sum;
};

bool hasPathSum(struct TreeNode* root, int targetSum){
    struct Pair stack[1000];
    int stackTop = 0;

    // è‹¥rootå­˜åœ¨ï¼Œåˆ™å°†èŠ‚ç‚¹å’Œå€¼å°è£…æˆä¸€ä¸ªpairå…¥æ ˆ
    if(root) {
        struct Pair newPair = {root, root->val};
        stack[stackTop++] = newPair;
    }

    // å½“æ ˆä¸ä¸ºç©ºæ—¶
    while(stackTop) {
        // å‡ºæ ˆæ ˆé¡¶å…ƒç´ 
        struct Pair topPair = stack[--stackTop];
        // è‹¥æ ˆé¡¶å…ƒç´ ä¸ºå¶å­èŠ‚ç‚¹ï¼Œä¸”å’Œä¸ºtargetSumæ—¶ï¼Œè¿”å›true
        if(!topPair.node->left && !topPair.node->right && topPair.sum == targetSum)
            return true;

        // è‹¥å½“å‰æ ˆé¡¶èŠ‚ç‚¹æœ‰å·¦å³å­©å­ï¼Œè®¡ç®—å’Œå¹¶å…¥æ ˆ
        if(topPair.node->left) {
            struct Pair newPair = {topPair.node->left, topPair.sum + topPair.node->left->val};
            stack[stackTop++] = newPair;
        }
        if(topPair.node->right) {
            struct Pair newPair = {topPair.node->right, topPair.sum + topPair.node->right->val};
            stack[stackTop++] = newPair;
        }
    }
    return false;
}
```

### 4ã€è‡ªå·±çå†™

* è‡ªå·±ä¸€å¼€å§‹çœ‹è¿™é“é¢˜æ—¶ï¼Œçå†™çš„è§£æ³•

```c
bool recursion(struct TreeNode* root, int targetSum,int curSum){
    if(root == NULL){
        return false;
    }
    curSum += root->val;
    if(root->left==NULL && root->right==NULL && curSum == targetSum){
        return true;
    }
    return recursion(root->left,targetSum,curSum) || recursion(root-> right,targetSum,curSum);
}

bool hasPathSum(struct TreeNode* root, int targetSum){
    if(root ==NULL){
        return 0;
    }
    return recursion(root,targetSum,0);

}
```

## åäº”ã€è·¯å¾„æ€»å’Œ2

### 1ã€é¢˜ç›®

> ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å’Œ targetSum ï¼Œæ‰¾å‡ºæ‰€æœ‰ ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ è·¯å¾„æ€»å’Œç­‰äºç»™å®šç›®æ ‡å’Œçš„è·¯å¾„ã€‚
>
> å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
>
> ![img](https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg)
>
> ```c
> ç¤ºä¾‹1ï¼š
> è¾“å…¥ï¼šroot = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
> è¾“å‡ºï¼š[[5,4,11,2],[5,8,4,5]]
> ```
>
> ![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)
>
> ```c
> ç¤ºä¾‹2ï¼š
> è¾“å…¥ï¼šroot = [1,2,3], targetSum = 5
> è¾“å‡ºï¼š[]
> ```
>
> ```c
> ç¤ºä¾‹3ï¼š
> è¾“å…¥ï¼šroot = [1,2], targetSum = 0
> è¾“å‡ºï¼š[]
> ```
>
> **æç¤ºï¼š**
>
> - æ ‘ä¸­èŠ‚ç‚¹æ€»æ•°åœ¨èŒƒå›´ `[0, 5000]` å†…
> - `-1000 <= Node.val <= 1000`
> - `-1000 <= targetSum <= 1000`



### 2ã€æ€è·¯

* åˆ›å»ºä¸€ä¸ªæ ˆå’Œç»“æœé˜Ÿåˆ—(äºŒç»´æ•°ç»„)

* é€’å½’è¿›å…¥ç›´åˆ°æœ€åä¸€å±‚ï¼Œåˆ¤æ–­sumæ•°ç»„æ˜¯å¦æ˜¯ä¸ºæŒ‡å®šè·¯åŠ²æ€»å’Œï¼Œæ˜¯å°±å°†æ ˆä¸­çš„å…ƒç´ æ‹·è´ä¸ªç»“æœæ•°ç»„

* é€’å½’:

  * 1. ä¼ å…¥å‚æ•°

    ```c
    void traversal(struct TreeNode *root,int targetSum,int * returnSize,int** returnColumnSizes,int**result,int* stack,int top,int sum)
    ```

    

  * 2. ç»“æŸæ¡ä»¶

    ```c
    //ç»“æŸæ¡ä»¶
    if(root ==NULL) return ;
    ```

  * 3.é€’å½’å¤„ç†

  ```
  sum += root->val;
      stack[top] = root->val;
      if(root->left==NULL && root ->right==NULL && sum == targetSum){
         //ç”³è¯·ç©ºé—´
         result[*returnSize] = (int*)malloc(sizeof(int)*(top+1));
         //æ‹·è´å†…å®¹
         memcpy(result[*returnSize],stack,sizeof(int)*(top+1));
         (* returnColumnSizes)[*returnSize] = top +1;
         *returnSize = *returnSize +1;
      }
  ```

### 3ã€ä»£ç 

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
void traversal(struct TreeNode *root,int targetSum,int * returnSize,int** returnColumnSizes,int**result,int* stack,int top,int sum){
    //ç»“æŸæ¡ä»¶
    if(root ==NULL) return ;
    //æ‰§è¡Œæ¡ä»¶ 
    sum += root->val;
    stack[top] = root->val;
    if(root->left==NULL && root ->right==NULL && sum == targetSum){
       //ç”³è¯·ç©ºé—´
       result[*returnSize] = (int*)malloc(sizeof(int)*(top+1));
       //æ‹·è´å†…å®¹
       memcpy(result[*returnSize],stack,sizeof(int)*(top+1));
       (* returnColumnSizes)[*returnSize] = top +1;
       *returnSize = *returnSize +1;
    }
    //éå†å·¦å­æ ‘
    traversal(root->left,targetSum,returnSize,returnColumnSizes,result,stack,top+1,sum);
    //éå†å³å­æ ‘
    traversal(root->right,targetSum,returnSize,returnColumnSizes,result,stack,top+1,sum);

}


int** pathSum(struct TreeNode* root, int targetSum, int* returnSize, int** returnColumnSizes) {
    int ** result= (int**)malloc(sizeof(int *)*5000);
    *returnColumnSizes =(int *)malloc(sizeof(int)*5000);
    int stack[5000] = {0}; 
    *returnSize =0;
    traversal(root,targetSum,returnSize,returnColumnSizes,result,stack,0,0);
    return result;
}

```

## åå…­ã€æœ€å¤§äºŒå‰æ ‘

[654. æœ€å¤§äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/maximum-binary-tree/submissions/)

### 1ã€é¢˜ç›®

> ç»™å®šä¸€ä¸ªä¸é‡å¤çš„æ•´æ•°æ•°ç»„ nums ã€‚ æœ€å¤§äºŒå‰æ ‘ å¯ä»¥ç”¨ä¸‹é¢çš„ç®—æ³•ä» nums é€’å½’åœ°æ„å»º:
>
> åˆ›å»ºä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå…¶å€¼ä¸º nums ä¸­çš„æœ€å¤§å€¼ã€‚
> é€’å½’åœ°åœ¨æœ€å¤§å€¼ å·¦è¾¹ çš„ å­æ•°ç»„å‰ç¼€ä¸Š æ„å»ºå·¦å­æ ‘ã€‚
> é€’å½’åœ°åœ¨æœ€å¤§å€¼ å³è¾¹ çš„ å­æ•°ç»„åç¼€ä¸Š æ„å»ºå³å­æ ‘ã€‚
> è¿”å› nums æ„å»ºçš„ æœ€å¤§äºŒå‰æ ‘ ã€‚
>
>  ![img](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg)
>
> ```c
> ç¤ºä¾‹ï¼š1
> è¾“å…¥ï¼šnums = [3,2,1,6,0,5]
> è¾“å‡ºï¼š[6,3,5,null,2,0,null,null,1]
> è§£é‡Šï¼šé€’å½’è°ƒç”¨å¦‚ä¸‹æ‰€ç¤ºï¼š
> - [3,2,1,6,0,5] ä¸­çš„æœ€å¤§å€¼æ˜¯ 6 ï¼Œå·¦è¾¹éƒ¨åˆ†æ˜¯ [3,2,1] ï¼Œå³è¾¹éƒ¨åˆ†æ˜¯ [0,5] ã€‚
>     - [3,2,1] ä¸­çš„æœ€å¤§å€¼æ˜¯ 3 ï¼Œå·¦è¾¹éƒ¨åˆ†æ˜¯ [] ï¼Œå³è¾¹éƒ¨åˆ†æ˜¯ [2,1] ã€‚
>         - ç©ºæ•°ç»„ï¼Œæ— å­èŠ‚ç‚¹ã€‚
>         - [2,1] ä¸­çš„æœ€å¤§å€¼æ˜¯ 2 ï¼Œå·¦è¾¹éƒ¨åˆ†æ˜¯ [] ï¼Œå³è¾¹éƒ¨åˆ†æ˜¯ [1] ã€‚
>             - ç©ºæ•°ç»„ï¼Œæ— å­èŠ‚ç‚¹ã€‚
>             - åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥å­èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå€¼ä¸º 1 çš„èŠ‚ç‚¹ã€‚
>     - [0,5] ä¸­çš„æœ€å¤§å€¼æ˜¯ 5 ï¼Œå·¦è¾¹éƒ¨åˆ†æ˜¯ [0] ï¼Œå³è¾¹éƒ¨åˆ†æ˜¯ [] ã€‚
>         - åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥å­èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå€¼ä¸º 0 çš„èŠ‚ç‚¹ã€‚
>         - ç©ºæ•°ç»„ï¼Œæ— å­èŠ‚ç‚¹ã€‚
> ```
>
> ![img](https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg)
>
> ```c
> ç¤ºä¾‹2ï¼š
> è¾“å…¥ï¼šnums = [3,2,1]
> è¾“å‡ºï¼š[3,null,2,null,1]
> ```
>
> **æç¤ºï¼š**
>
> - `1 <= nums.length <= 1000`
> - `0 <= nums[i] <= 1000`
> - `nums` ä¸­çš„æ‰€æœ‰æ•´æ•° **äº’ä¸ç›¸åŒ**

### 2ã€æ€è·¯

* æ‰¾åˆ°æ•°ç»„æœ€å¤§å€¼ä¸‹æ ‡ï¼Œåˆ‡å‰²å·¦å³æ•°ç»„

### 3ã€ä»£ç 

```c
struct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize){
    //å¦‚æœæ•°ç»„å¤§å°ä¸º0ï¼Œè¯´æ˜æ•°ç»„ä¸ºç©ºï¼Œè¿”å› NULL
    if(numsSize ==0){
        return NULL;
    }
    //æ•°ç»„ä¸ä¸º NULL
    int maxIndex = 0;
    //æ‰¾åˆ°æ•°ç»„ä¸­æœ€å¤§çš„æ•°åæ ‡ï¼Œåšä¸ºåˆ‡å‰²ç‚¹
    for(int i=1;i<numsSize;i++){
        if(nums[i] > nums[maxIndex]){
            maxIndex =i;
        }
    }

    //å¼€è¾Ÿç»“ç‚¹
    struct TreeNode* node =(struct TreeNode*)malloc(sizeof(struct TreeNode));
    node->val = nums[maxIndex];

    //é€’å½’å®šä¹‰å·¦å­©å­å’Œå³å­©å­
    int rightSize = numsSize - maxIndex -1;
    //åˆ‡å‰²å·¦å³æ•°ç»„
    node->left = constructMaximumBinaryTree(nums,maxIndex);
    node->right = constructMaximumBinaryTree(nums+maxIndex+1,rightSize);

    return node;
}
```

