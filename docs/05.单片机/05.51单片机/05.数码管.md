---
title: 数码管
date: 2023-09-13 09:58:49
permalink: /pages/c2ac64/
categories:
  - 单片机
  - 51单片机
tags:
  - 
author: 
  name: JackCin
  link: https://github.com/JackCin877
---
# 数码管

* LED数码管：数码管是一种简单、廉价的显示器，是由多个发光二极管封装在一起组成“8”字型的器件。
  *   首先，我们先来研究一个数码管，右图是两种连接方式，一种是共阴极的连接方法， 另一种是共阳极的连接方法，开发板就是共阴极连接的，所以我们只讲解共阴极，共阳极的原理也是一样的，就不细细讲解。首先，负极接地（位选），再对各个引脚赋值（和LED那章类似），就可以显示出相应的数字了。

![数码管引脚定义](https://cdn.staticaly.com/gh/JackCin877/image-hosting@master/51MUC/数码管引脚定义.43duj0xw27i0.webp)

* 右上图为共阴极连接，3，8（**位选端**接GND），即位选端为0，其他引脚为1时，就会发亮

* 例如给，7~5：1011 1110  就会显示数字6，（1011 1110）就被成为**段码**
* 右下为共阳极连接，位选端接VCC，所以要让LED发亮需要位选端为1，其他引脚为0

>  之后，我们就要开始研究四位一体的数码管了，四位一体的数码管并不是单纯的把四个数码管拼接在一起，那样引脚数码过多，不利与操作。个人认为这个四位一体数码管设计的十分巧妙，仅仅使用了12个引脚就解决了（一个数码管是10个引脚，就加了2个引脚，却能多控制3个数码管），让我们来看看四位一体的数码管的构造吧！
> ![img](https://img-blog.csdnimg.cn/b30bddebdae2441f8510a0cd11752967.png)

## 1、原理图

![数码管](https://cdn.staticaly.com/gh/JackCin877/image-hosting@master/51MUC/数码管.12exyxnrocj4.webp)

* 位选为0，其他为1，就发亮
* 由图可见，要想控制数码管的位选端，就应该控制 **LED1~8**,而位选端是靠**138译码器**来控制的
* **74HC245  双向数据缓冲器**



### 1.1、138译码器

![138译码器](https://cdn.staticaly.com/gh/JackCin877/image-hosting@master/51MUC/138译码器.5q9z3jdtlq40.webp)

* 138译码器，要想正常工作，需要使能有效，（左下角3个G）是使能端，G1接高电平，其他低电平时使能有效，（原理图直接就是按这样接的）

* **138译码器，就是把8个端口由3个端口来控制，减少了单片机的I\O口**
* 转换规则：
  * CBA为000，则对应为0，Y0置为0
  * CBA为001，则对应为1，Y1置为0
  * CBA为010，则对应为2，Y2置为0
  * 如此类推
* 从这里也可以看出，为什么我们打开单片机，数码管默认显示了 8.  ，就是因为I/O口默认为高电平，即CBA为111，对应Y7就为0，LED8位选被选中，所以LED8发亮

 

### 1.2 74HC245 双向数据缓冲器

![74HC245原理图](https://cdn.staticaly.com/gh/JackCin877/image-hosting@master/51MUC/74HC245原理图.573qpzyhzzk0.webp)

* **DIR，(direction 方向)控制数据传输方向**，接的是 **J21模块的LE**，如果接**高电平**就把左边数据送到右边去（反之）

* **OE 控制芯片的使能**，（其实应该叫CE，Chip Enable 芯片使能端）

* **滤波电容** 稳定电源，确保电路稳定性提高电路工作性能可靠运行

  * 104==》 10* 10^4 = 100 000 **(pF)**

  * 1法拉（F）

    = 10^3毫法（mF）

    =10^6微法（μF）

    =10^9纳法（nF）

    =10^12皮法（pF）

* 之所以要加**（74HC245）双向数据缓冲器**是因为单片机的电压强度不能太大，高电平驱动能力比较弱，所以要加一个**缓冲器来提高驱动能力**，如果直接把单片机接到数码管上，那它的驱动能力就比较弱，但是我们经过缓冲器（74HC245芯片）后再接，那就相当于是一种控制信号，即使很微弱，只要74HC245收到就会向自己连接的VCC上获得能量

![74HC245引脚对应数码管引脚](https://cdn.staticaly.com/gh/JackCin877/image-hosting@master/51MUC/74HC245引脚对应数码管引脚.7gvwx5mwruo0.webp)

### 1.3 J21

* 控制数据流动的方向

(看江科大的视频STC89C52的板子里有，但是博主自己买的STC89C52的板子好像没有，似乎是直接就DIR接的VCC)

![J21](https://cdn.staticaly.com/gh/JackCin877/image-hosting@master/51MUC/J21.64va3f1dr4g0.webp)

* 视频里的板子直接用跳线帽连接的 **LE** 和 **VCC**，**相当于始终给 LE 高电平**，高电平情况下，**DIR 就控制数据从左向右传输**



## 2、动态数码管显示

* 需要注意的点：**消影**。
  * 因为我们的顺序是  **位选  段选   位选  段选  位选  段选**（这种情况下在执行完一次显示函数后，段选没变，但是位选变化，就会出现**数值错乱**的情况）
  * 解决这种情况的方法就是：<font color="skyblue">位选  段选  **清零**  位选  段选 </font>

```c
#include <REGX52.H>

//数码管段码表
unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};

//延时子函数
void Delay(unsigned int xms)
{
	unsigned char i, j;
	while(xms--)
	{
		i = 2;
		j = 239;
		do
		{
			while (--j);
		} while (--i);
	}
}

//数码管显示子函数
void Nixie(unsigned char Location,Number)
{
	switch(Location)		//位码输出
	{
		case 1:P2_4=1;P2_3=1;P2_2=1;break;
		case 2:P2_4=1;P2_3=1;P2_2=0;break;
		case 3:P2_4=1;P2_3=0;P2_2=1;break;
		case 4:P2_4=1;P2_3=0;P2_2=0;break;
		case 5:P2_4=0;P2_3=1;P2_2=1;break;
		case 6:P2_4=0;P2_3=1;P2_2=0;break;
		case 7:P2_4=0;P2_3=0;P2_2=1;break;
		case 8:P2_4=0;P2_3=0;P2_2=0;break;
	}
	P0=NixieTable[Number];	//段码输出
	Delay(1);			//显示一段时间,如果立马清零的话显示会比较暗
	P0=0x00;				//段码清0，消影
}

void main()
{
	while(1)
	{
		Nixie(1,1);		//在数码管的第1位置显示1
//		Delay(20);
		Nixie(2,2);		//在数码管的第2位置显示2
//		Delay(20);
		Nixie(3,3);		//在数码管的第3位置显示3
//		Delay(20);
	}
}

```



## 3、数码管驱动扫描方式

* 单片机直接扫描：硬件设备简单，但会耗费大量的单片机CPU时间
  * 本次学习过程用的就是单片机直接扫描

* 专用驱动芯片：内部自带显存、扫描电路，单片机只需告诉它显示什么即可

