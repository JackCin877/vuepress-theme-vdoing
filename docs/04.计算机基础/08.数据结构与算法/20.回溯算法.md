---
title: å›æº¯ç®—æ³•
date: 2023-09-13 09:07:39
permalink: /pages/e87317/
categories:
  - è®¡ç®—æœºåŸºç¡€
  - æ•°æ®ç»“æ„
tags:
  - 
author: 
  name: JackCin
  link: https://github.com/JackCin877
---
# å›æº¯ç®—æ³•ï¼ˆä¸Šï¼‰

## 1ã€å›æº¯ç®—æ³•ç†è®ºåŸºç¡€

[ä»£ç éšæƒ³å½• (programmercarl.com)](https://www.programmercarl.com/å›æº¯ç®—æ³•ç†è®ºåŸºç¡€.html#é¢˜ç›®åˆ†ç±»å¤§çº²å¦‚ä¸‹)

å›æº¯æ³•æ¨¡æ¿ï¼š

```c
void backtracking(å‚æ•°) {
    if (ç»ˆæ­¢æ¡ä»¶) {
        å­˜æ”¾ç»“æœ;
        return;
    }

    for (é€‰æ‹©ï¼šæœ¬å±‚é›†åˆä¸­å…ƒç´ ï¼ˆæ ‘ä¸­èŠ‚ç‚¹å­©å­çš„æ•°é‡å°±æ˜¯é›†åˆçš„å¤§å°ï¼‰) {
        å¤„ç†èŠ‚ç‚¹;
        backtracking(è·¯å¾„ï¼Œé€‰æ‹©åˆ—è¡¨); // é€’å½’
        å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ
    }
}
```



## 2ã€ç»„åˆé—®é¢˜

### 1ã€é¢˜ç›®

> ç»™å®šä¸¤ä¸ªæ•´æ•° `n` å’Œ `k`ï¼Œè¿”å›èŒƒå›´ `[1, n]` ä¸­æ‰€æœ‰å¯èƒ½çš„ `k` ä¸ªæ•°çš„ç»„åˆã€‚
>
> ä½ å¯ä»¥æŒ‰ **ä»»ä½•é¡ºåº** è¿”å›ç­”æ¡ˆã€‚
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> 
> è¾“å…¥ï¼šn = 4, k = 2
> è¾“å‡ºï¼š
> [
>   [2,4],
>   [3,4],
>   [2,3],
>   [1,2],
>   [1,3],
>   [1,4],
> ]
>     
> ç¤ºä¾‹ 2ï¼š
> 
> è¾“å…¥ï¼šn = 1, k = 1
> è¾“å‡ºï¼š[[1]]
> ```
>
> **æç¤ºï¼š**
>
> - `1 <= n <= 20`
> - `1 <= k <= n`

### 2ã€æ€è·¯

#### 2.1 æš´åŠ›è§£æ³•

* ç›´æ¥çš„è§£æ³•å½“ç„¶æ˜¯ä½¿ç”¨forå¾ªç¯ï¼Œä¾‹å¦‚ç¤ºä¾‹ä¸­kä¸º2ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ° ç”¨ä¸¤ä¸ªforå¾ªç¯ï¼Œè¿™æ ·å°±å¯ä»¥è¾“å‡º å’Œç¤ºä¾‹ä¸­ä¸€æ ·çš„ç»“æœã€‚

```c
int n = 4;
for (int i = 1; i <= n; i++) {
    for (int j = i + 1; j <= n; j++) {
        cout << i << " " << j << endl;
    }
}
```

```c
è¾“å…¥ï¼šn = 100, k = 3 é‚£ä¹ˆå°±ä¸‰å±‚forå¾ªç¯ï¼Œä»£ç å¦‚ä¸‹ï¼š

int n = 100;
for (int i = 1; i <= n; i++) {
    for (int j = i + 1; j <= n; j++) {
        for (int u = j + 1; u <= n; n++) {
            cout << i << " " << j << " " << u << endl;
        }
    }
}
```

* **å¦‚æœnä¸º100ï¼Œkä¸º50å‘¢ï¼Œé‚£å°±50å±‚forå¾ªç¯**ï¼Œæ˜¯ä¸æ˜¯å¼€å§‹çª’æ¯ï¼Œæ‰€ä»¥è¦ç”¨**å›æº¯æ³•**

#### 2. 2 å›æº¯æ³•

* **å›æº¯æ³•è§£å†³çš„é—®é¢˜éƒ½å¯ä»¥æŠ½è±¡ä¸ºæ ‘å½¢ç»“æ„ï¼ˆNå‰æ ‘ï¼‰ï¼Œç”¨æ ‘å½¢ç»“æ„æ¥ç†è§£å›æº¯å°±å®¹æ˜“å¤šäº†**ã€‚

* æŠŠç»„åˆé—®é¢˜æŠ½è±¡ä¸ºå¦‚ä¸‹æ ‘å½¢ç»“æ„ï¼š

![77.ç»„åˆ](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195223940.png)

* å¯ä»¥çœ‹å‡ºè¿™æ£µæ ‘ï¼Œä¸€å¼€å§‹é›†åˆæ˜¯ 1ï¼Œ2ï¼Œ3ï¼Œ4ï¼Œ ä»å·¦å‘å³å–æ•°ï¼Œå–è¿‡çš„æ•°ï¼Œä¸å†é‡å¤å–ã€‚

* ç¬¬ä¸€æ¬¡å–1ï¼Œé›†åˆå˜ä¸º2ï¼Œ3ï¼Œ4 ï¼Œå› ä¸ºkä¸º2ï¼Œæˆ‘ä»¬åªéœ€è¦å†å–ä¸€ä¸ªæ•°å°±å¯ä»¥äº†ï¼Œåˆ†åˆ«å–2ï¼Œ3ï¼Œ4ï¼Œå¾—åˆ°é›†åˆ[1,2] [1,3] [1,4]ï¼Œä»¥æ­¤ç±»æ¨ã€‚
* **æ¯æ¬¡ä»é›†åˆä¸­é€‰å–å…ƒç´ ï¼Œå¯é€‰æ‹©çš„èŒƒå›´éšç€é€‰æ‹©çš„è¿›è¡Œè€Œæ”¶ç¼©ï¼Œè°ƒæ•´å¯é€‰æ‹©çš„èŒƒå›´**ã€‚
* **å›¾ä¸­å¯ä»¥å‘ç°nç›¸å½“äºæ ‘çš„å®½åº¦ï¼Œkç›¸å½“äºæ ‘çš„æ·±åº¦**ã€‚
* é‚£ä¹ˆå¦‚ä½•åœ¨è¿™ä¸ªæ ‘ä¸Šéå†ï¼Œç„¶åæ”¶é›†åˆ°æˆ‘ä»¬è¦çš„ç»“æœé›†å‘¢ï¼Ÿ
  * **å›¾ä¸­æ¯æ¬¡æœç´¢åˆ°äº†å¶å­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å°±æ‰¾åˆ°äº†ä¸€ä¸ªç»“æœ**ã€‚
  * ç›¸å½“äºåªéœ€è¦æŠŠè¾¾åˆ°å¶å­èŠ‚ç‚¹çš„ç»“æœæ”¶é›†èµ·æ¥ï¼Œå°±å¯ä»¥æ±‚å¾— nä¸ªæ•°ä¸­kä¸ªæ•°çš„ç»„åˆé›†åˆã€‚

- å•å±‚æœç´¢çš„è¿‡ç¨‹
  - å›æº¯æ³•çš„æœç´¢è¿‡ç¨‹å°±æ˜¯ä¸€ä¸ªæ ‘å‹ç»“æ„çš„éå†è¿‡ç¨‹ï¼Œåœ¨å¦‚ä¸‹å›¾ä¸­ï¼Œå¯ä»¥çœ‹å‡ºforå¾ªç¯ç”¨æ¥æ¨ªå‘éå†ï¼Œé€’å½’çš„è¿‡ç¨‹æ˜¯çºµå‘éå†ã€‚

![77.ç»„åˆ1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png)

### 3ã€ä»£ç 

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */

int** result; //åšä¸ºè¿”å›å€¼è¿”å›çš„äºŒç»´æ•°ç»„
int resultTop; //è®°å½•æ•°é‡
int *path ; // éå†è·¯å¾„
int pathTop; //è®°å½•å·²éå†è·¯å¾„æ•°ç›®

void backtracking(int n,int k, int stratIndex){
    //å½“path ä¸­çš„å…ƒç´ ä¸ºkæ—¶ï¼Œå°†pathæ•°ç»„æ”¾å…¥ result æ•°ç»„ä¸­
    if(pathTop == k){
        //pathæ•°ç»„ä¸ºæˆ‘ä»¬åŠ¨æ€ç”³è¯·ï¼Œè‹¥ç›´æ¥å°†å…¶åœ°å€æ”¾å…¥äºŒç»´æ•°ç»„ï¼Œpathæ•°ç»„ä¸­çš„å€¼ä¼šéšç€æˆ‘ä»¬å›æº¯è€Œé€æ¸å˜åŒ–
        //å› æ­¤åˆ›å»ºæ–°çš„æ•°ç»„å­˜å‚¨pathä¸­çš„å€¼
        int * temp =(int* )malloc(sizeof(int)*k);
        for(int i =0;i<k;i++){
            temp[i] = path[i];
        }
        result[resultTop++] = temp;
        return ;
    }
    // forå¾ªç¯æ§åˆ¶å®½åº¦ï¼Œå›æº¯å‡½æ•°ä¸ºæ·±åº¦
    for(int i = stratIndex; i <= n ; i++ ){
        path[pathTop++] = i;
        backtracking(n , k , i + 1);
        pathTop--;
    }
}

int** combine(int n, int k, int* returnSize, int** returnColumnSizes){
    // path æ•°ç»„å­˜å‚¨ç¬¦åˆæ¡ä»¶çš„ç»“æœ
    path = (int*)malloc(sizeof(int)*k);
    // result äºŒç»´æ•°ç»„å­˜å‚¨ç¬¦åˆæ¡ä»¶çš„ç»“æœæ•°ç»„çš„é›†åˆï¼ˆæ•°ç»„è¶³å¤Ÿå¤§ï¼Œé¿å…æç«¯æƒ…å†µï¼‰
    result = (int ** )malloc(sizeof(int*)*10000);
    resultTop = pathTop = 0;

    // å›æº¯ç®—æ³•
    backtracking(n,k,1);

    *returnSize = resultTop;
    *returnColumnSizes = (int*) malloc(sizeof(int)*(*returnSize));
    for(int i = 0;i < (*returnSize);i++){
        (*returnColumnSizes)[i] = k;
    }
    return result;
}
```

### 4ã€å‰ªæä¼˜åŒ–

* æ¥ä¸¾ä¸€ä¸ªä¾‹å­ï¼Œn = 4ï¼Œk = 4çš„è¯ï¼Œé‚£ä¹ˆç¬¬ä¸€å±‚forå¾ªç¯çš„æ—¶å€™ï¼Œä»å…ƒç´ 2å¼€å§‹çš„éå†éƒ½æ²¡æœ‰æ„ä¹‰äº†ã€‚ åœ¨ç¬¬äºŒå±‚forå¾ªç¯ï¼Œä»å…ƒç´ 3å¼€å§‹çš„éå†éƒ½æ²¡æœ‰æ„ä¹‰äº†ã€‚

* è¿™ä¹ˆè¯´æœ‰ç‚¹æŠ½è±¡ï¼Œå¦‚å›¾æ‰€ç¤ºï¼š

![77.ç»„åˆ4](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130194335207-20230310134409532.png)

* å›¾ä¸­æ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆå›¾ä¸­ä¸ºçŸ©å½¢ï¼‰ï¼Œå°±ä»£è¡¨æœ¬å±‚çš„ä¸€ä¸ªforå¾ªç¯ï¼Œé‚£ä¹ˆæ¯ä¸€å±‚çš„forå¾ªç¯ä»ç¬¬äºŒä¸ªæ•°å¼€å§‹éå†çš„è¯ï¼Œéƒ½æ²¡æœ‰æ„ä¹‰ï¼Œéƒ½æ˜¯æ— æ•ˆéå†ã€‚

  **æ‰€ä»¥ï¼Œå¯ä»¥å‰ªæçš„åœ°æ–¹å°±åœ¨é€’å½’ä¸­æ¯ä¸€å±‚çš„forå¾ªç¯æ‰€é€‰æ‹©çš„èµ·å§‹ä½ç½®**ã€‚

  **å¦‚æœforå¾ªç¯é€‰æ‹©çš„èµ·å§‹ä½ç½®ä¹‹åçš„å…ƒç´ ä¸ªæ•° å·²ç»ä¸è¶³ æˆ‘ä»¬éœ€è¦çš„å…ƒç´ ä¸ªæ•°äº†ï¼Œé‚£ä¹ˆå°±æ²¡æœ‰å¿…è¦æœç´¢äº†**ã€‚

* æ³¨æ„ä»£ç ä¸­iï¼Œå°±æ˜¯forå¾ªç¯é‡Œé€‰æ‹©çš„èµ·å§‹ä½ç½®ã€‚

  ```c
  for (int i = startIndex; i <= n; i++) {
  ```

  æ¥ä¸‹æ¥çœ‹ä¸€ä¸‹ä¼˜åŒ–è¿‡ç¨‹å¦‚ä¸‹ï¼š

  1. å·²ç»é€‰æ‹©çš„å…ƒç´ ä¸ªæ•°ï¼špath.size();
  2. è¿˜éœ€è¦çš„å…ƒç´ ä¸ªæ•°ä¸º: k - path.size();
  3. åœ¨é›†åˆnä¸­è‡³å¤šè¦ä»è¯¥èµ·å§‹ä½ç½® : n - (k - path.size()) + 1ï¼Œå¼€å§‹éå†

* ä¸ºä»€ä¹ˆæœ‰ä¸ª+1å‘¢ï¼Œå› ä¸ºåŒ…æ‹¬èµ·å§‹ä½ç½®ï¼Œæˆ‘ä»¬è¦æ˜¯ä¸€ä¸ªå·¦é—­çš„é›†åˆã€‚

  * ä¸¾ä¸ªä¾‹å­ï¼Œn = 4ï¼Œk = 3ï¼Œ ç›®å‰å·²ç»é€‰å–çš„å…ƒç´ ä¸º0ï¼ˆpath.sizeä¸º0ï¼‰ï¼Œn - (k - 0) + 1 å³ 4 - ( 3 - 0) + 1 = 2ã€‚
  * ä»2å¼€å§‹æœç´¢éƒ½æ˜¯åˆç†çš„ï¼Œå¯ä»¥æ˜¯ç»„åˆ[2, 3, 4]ã€‚
  * è¿™é‡Œå¤§å®¶æƒ³ä¸æ‡‚çš„è¯ï¼Œå»ºè®®ä¹Ÿä¸¾ä¸€ä¸ªä¾‹å­ï¼Œå°±çŸ¥é“æ˜¯ä¸æ˜¯è¦+1äº†ã€‚
  * æ‰€ä»¥ä¼˜åŒ–ä¹‹åçš„forå¾ªç¯æ˜¯ï¼š

  ```c
  for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) // iä¸ºæœ¬æ¬¡æœç´¢çš„èµ·å§‹ä½ç½®
  ```

## 3ã€ç»„åˆæ€»å’ŒIII

### 1ã€é¢˜ç›®

> æ‰¾å‡ºæ‰€æœ‰ç›¸åŠ ä¹‹å’Œä¸º n çš„ k ä¸ªæ•°çš„ç»„åˆï¼Œä¸”æ»¡è¶³ä¸‹åˆ—æ¡ä»¶ï¼š
>
> * åªä½¿ç”¨æ•°å­—1åˆ°9
> * æ¯ä¸ªæ•°å­— æœ€å¤šä½¿ç”¨ä¸€æ¬¡ 
>
> è¿”å› **æ‰€æœ‰å¯èƒ½çš„æœ‰æ•ˆç»„åˆçš„åˆ—è¡¨** ã€‚è¯¥åˆ—è¡¨ä¸èƒ½åŒ…å«ç›¸åŒçš„ç»„åˆä¸¤æ¬¡ï¼Œç»„åˆå¯ä»¥ä»¥ä»»ä½•é¡ºåºè¿”å›ã€‚
>
>  ç¤ºä¾‹ 1:
>
> ```c
> è¾“å…¥: k = 3, n = 7
> è¾“å‡º: [[1,2,4]]
> è§£é‡Š:
> 1 + 2 + 4 = 7
> æ²¡æœ‰å…¶ä»–ç¬¦åˆçš„ç»„åˆäº†ã€‚
> ```
>
> ç¤ºä¾‹ 2:
>
> ```c
> è¾“å…¥: k = 3, n = 9
> è¾“å‡º: [[1,2,6], [1,3,5], [2,3,4]]
> è§£é‡Š:
> 1 + 2 + 6 = 9
> 1 + 3 + 5 = 9
> 2 + 3 + 4 = 9
> æ²¡æœ‰å…¶ä»–ç¬¦åˆçš„ç»„åˆäº†ã€‚
> ```
>
> ç¤ºä¾‹ 3:
>
> ```c
> è¾“å…¥: k = 4, n = 1
> è¾“å‡º: []
> è§£é‡Š: ä¸å­˜åœ¨æœ‰æ•ˆçš„ç»„åˆã€‚
> åœ¨[1,9]èŒƒå›´å†…ä½¿ç”¨4ä¸ªä¸åŒçš„æ•°å­—ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°çš„æœ€å°å’Œæ˜¯1+2+3+4 = 10ï¼Œå› ä¸º10 > 1ï¼Œæ²¡æœ‰æœ‰æ•ˆçš„ç»„åˆã€‚
> 
> ```
>
> * æç¤º:
>   * 2 <= `k` <= 9
>   * 1 <= `n` <= 60

### 2ã€æ€è·¯

* æ€è·¯ä¸ä¸Šé¢˜åŸºæœ¬ä¸€è‡´ï¼ˆä¸å¤šè¯´ï¼‰

### 3ã€ä»£ç 

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */

int **result;
int * path;
int resultTop;
int pathTop;

void backtracking(int n,int k ,int stratIndex,int sum){
    if(pathTop == k){
        if(sum == n){
        //pathæ•°ç»„ä¸ºæˆ‘ä»¬åŠ¨æ€ç”³è¯·ï¼Œè‹¥ç›´æ¥å°†å…¶åœ°å€æ”¾å…¥äºŒç»´æ•°ç»„ï¼Œpathæ•°ç»„ä¸­çš„å€¼ä¼šéšç€æˆ‘ä»¬å›æº¯è€Œé€æ¸å˜åŒ–
        //å› æ­¤åˆ›å»ºæ–°çš„æ•°ç»„å­˜å‚¨pathä¸­çš„å€¼
        int* temp = (int*)malloc(sizeof(int)*k); 
        for(int i=0;i<k;i++){
            temp[i]= path[i];
        }
        result[resultTop++] = temp;
        return ;
        }
        return ;
    }
    
    // forå¾ªç¯æ§åˆ¶å®½åº¦ï¼Œå›æº¯å‡½æ•°ä¸ºæ·±åº¦
    for(int i=stratIndex;i<= 9;i++){
        path[pathTop++] = i;
        sum += i;
        // ä¸‹ä¸€æ¬¡èµ·å§‹ä½å°±åŠ ä¸€
        backtracking(n,k,i+1,sum);
        sum -= i;
        pathTop--;
    }

}

int** combinationSum3(int k, int n, int* returnSize, int** returnColumnSizes){
    
    //åˆå§‹åŒ–è¾…åŠ©å˜é‡
    result = (int **)malloc(sizeof(int*)* 10000);
    path = (int *)malloc(sizeof(int) * k);
    pathTop = resultTop =0; 

    backtracking(n,k,1,0);

    *returnSize = resultTop;
    * returnColumnSizes = (int*)malloc(sizeof(int)* resultTop);
    for(int i=0;i<(*returnSize);i++){
        (*returnColumnSizes)[i] = k; 
    }
    return result;
}
```

* å‰ªæä¼˜åŒ–ä¹Ÿç›¸åŒï¼Œéƒ½æ˜¯æŠŠforå¾ªç¯åˆ¤æ–­è¯­å¥æ”¹ä¸ºï¼š

  ```c
   for(int i=stratIndex;i<= 9- (k - pathTop) + 1;i++){
  ```




## 4ã€ç”µè¯å·ç å­—æ¯ç»„åˆ

[17. ç”µè¯å·ç çš„å­—æ¯ç»„åˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

### 1ã€é¢˜ç›®

> * ç»™å®šä¸€ä¸ªä»…åŒ…å«æ•°å­— 2-9 çš„å­—ç¬¦ä¸²ï¼Œè¿”å›æ‰€æœ‰å®ƒèƒ½è¡¨ç¤ºçš„å­—æ¯ç»„åˆã€‚ç­”æ¡ˆå¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ã€‚
>
> * ç»™å‡ºæ•°å­—åˆ°å­—æ¯çš„æ˜ å°„å¦‚ä¸‹ï¼ˆä¸ç”µè¯æŒ‰é”®ç›¸åŒï¼‰ã€‚æ³¨æ„ 1 ä¸å¯¹åº”ä»»ä½•å­—æ¯ã€‚
>
>   ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)
>
>   ```c
>   ç¤ºä¾‹ 1ï¼š
>   è¾“å…¥ï¼šdigits = "23"
>   è¾“å‡ºï¼š["ad","ae","af","bd","be","bf","cd","ce","cf"]
>       
>   ç¤ºä¾‹ 2ï¼š
>   è¾“å…¥ï¼šdigits = ""
>   è¾“å‡ºï¼š[]
>       
>   ç¤ºä¾‹ 3ï¼š
>   è¾“å…¥ï¼šdigits = "2"
>   è¾“å‡ºï¼š["a","b","c"]
>   ```
>
> * æç¤ºï¼š
>
>   * 0 <= `digits.length` <= 4
>   * `digits[i]` æ˜¯èŒƒå›´ `['2', '9']` çš„ä¸€ä¸ªæ•°å­—ã€‚

### 2ã€æ€è·¯

* æœ¬é¢˜ä¸»è¦è§£å†³ä¸‹é¢ä¸‰ä¸ªé—®é¢˜ï¼š
  * æ•°å­—å’Œå­—æ¯å¦‚ä½•æ˜ å°„
  * ä¸¤ä¸ªå­—æ¯å°±ä¸¤ä¸ªforå¾ªç¯ï¼Œä¸‰ä¸ªå­—ç¬¦æˆ‘å°±ä¸‰ä¸ªforå¾ªç¯ï¼Œä»¥æ­¤ç±»æ¨ï¼Œç„¶åå‘ç°ä»£ç æ ¹æœ¬å†™ä¸å‡ºæ¥
  * è¾“å…¥1 * #æŒ‰é”®ç­‰ç­‰å¼‚å¸¸æƒ…å†µ

#### 2.1 æ˜ å°„è§£å†³

* ä½¿ç”¨mapæˆ–è€…å®šä¹‰ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œä¾‹å¦‚ï¼š`string letterMap[10]`ï¼Œæ¥åšæ˜ å°„ï¼Œæˆ‘è¿™é‡Œå®šä¹‰ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œä»£ç å¦‚ä¸‹ï¼š

```c
const string letterMap[10] = {
    "", // 0
    "", // 1
    "abc", // 2
    "def", // 3
    "ghi", // 4
    "jkl", // 5
    "mno", // 6
    "pqrs", // 7
    "tuv", // 8
    "wxyz", // 9
};
```

#### 2.2 å›æº¯è§£å†³nä¸ªå¾ªç¯

![17. ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123200304469.png)

* `digits` çš„é•¿åº¦ä½œä¸ºå›æº¯çš„æ·±åº¦ï¼Œæ˜ å°„é‡Œå¯¹åº”çš„å­—ç¬¦ä¸²çš„é•¿åº¦ä¸ºé•¿åº¦

#### 2.3 å¼‚å¸¸æƒ…å†µ

* æ³¨æ„ï¼š**è¾“å…¥1 * #æŒ‰é”®ç­‰ç­‰å¼‚å¸¸æƒ…å†µ**
* ä»£ç ä¸­æœ€å¥½è€ƒè™‘è¿™äº›å¼‚å¸¸æƒ…å†µï¼Œä½†é¢˜ç›®çš„æµ‹è¯•æ•°æ®ä¸­åº”è¯¥æ²¡æœ‰å¼‚å¸¸æƒ…å†µçš„æ•°æ®ï¼Œæ‰€ä»¥æˆ‘å°±æ²¡æœ‰åŠ äº†ã€‚

### 3ã€ä»£ç 

```c
char* path;
int pathTop;
char** result;
int resultTop;
char* letterMap[10] = {"", //0
        "", //1
        "abc", //2
        "def", //3
        "ghi", //4
        "jkl", //5
        "mno", //6
        "pqrs", //7
        "tuv", //8
        "wxyz", //9
};
void backTracking(char* digits,int index){
    if(index== strlen(digits)){
        //æœ€åè¦æ·»åŠ ä¸€ä¸ª0ï¼ˆç»“æŸç¬¦ï¼‰ï¼Œæ‰€ä»¥è¦åŠ ä¸€
        char * temp = (char*)malloc(sizeof(char)* index+1);
        for(int i=0; i< index;i++){
            temp[i] = path[i]; 
        }
        // å› ä¸ºæ˜¯å­—ç¬¦æ•°ç»„ï¼Œæ‰€ä»¥è¦åœ¨åé¢åŠ ä¸€ä¸ª 0 ï¼Œè¡¨ç¤ºç»“æŸ
        temp[index] =0;
        result[resultTop++] = temp;
        return;
    }

    //å°†å­—ç¬¦æ•°å­—è½¬æ¢ä¸ºçœŸçš„æ•°å­—
    int digit = digits[index] - '0';//æ¯æ¬¡å–å‡ºå¯¹åº”æ•°å­—ï¼Œç»™ä¸‹é¢æ˜ å°„ä½¿ç”¨
    //æ‰¾åˆ°letterMapä¸­å¯¹åº”çš„å­—ç¬¦ä¸²
    char* letters = letterMap[digit];  
    for(int i=0;i<strlen(letters);i++){
        path[pathTop++] = letters[i];
        backTracking(digits,index+1);
        pathTop--;
    }
}


char ** letterCombinations(char * digits, int* returnSize){
    path = (char *)malloc(sizeof(char)*strlen(digits));
    result = (char**)malloc(sizeof(char*)* 10000);
    * returnSize = 0;

    if(strlen(digits) == 0 ){
        return result;
    }
    pathTop = resultTop =0;
    backTracking(digits,0);
    * returnSize = resultTop;
    return result;
}
```

## 5ã€ç»„åˆæ€»å’Œ

[39. ç»„åˆæ€»å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/combination-sum/)

### 1ã€é¢˜ç›®

> * ç»™ä½ ä¸€ä¸ª **æ— é‡å¤å…ƒç´ ** çš„æ•´æ•°æ•°ç»„ `candidates` å’Œä¸€ä¸ªç›®æ ‡æ•´æ•° `target` ï¼Œæ‰¾å‡º `candidates` ä¸­å¯ä»¥ä½¿æ•°å­—å’Œä¸ºç›®æ ‡æ•° `target` çš„ æ‰€æœ‰ **ä¸åŒç»„åˆ** ï¼Œå¹¶ä»¥åˆ—è¡¨å½¢å¼è¿”å›ã€‚ä½ å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›è¿™äº›ç»„åˆã€‚
>
> * `candidates` ä¸­çš„ **åŒä¸€ä¸ª** æ•°å­—å¯ä»¥ **æ— é™åˆ¶é‡å¤è¢«é€‰å–** ã€‚å¦‚æœè‡³å°‘ä¸€ä¸ªæ•°å­—çš„è¢«é€‰æ•°é‡ä¸åŒï¼Œåˆ™ä¸¤ç§ç»„åˆæ˜¯ä¸åŒçš„ã€‚ 
>
>   å¯¹äºç»™å®šçš„è¾“å…¥ï¼Œä¿è¯å’Œä¸º `target` çš„ä¸åŒç»„åˆæ•°å°‘äº `150` ä¸ªã€‚
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> è¾“å…¥ï¼šcandidates = [2,3,6,7], target = 7
> è¾“å‡ºï¼š[[2,2,3],[7]]
> è§£é‡Šï¼š
> 	- 2 å’Œ 3 å¯ä»¥å½¢æˆä¸€ç»„å€™é€‰ï¼Œ2 + 2 + 3 = 7 ã€‚æ³¨æ„ 2 å¯ä»¥ä½¿ç”¨å¤šæ¬¡ã€‚
> 	- 7 ä¹Ÿæ˜¯ä¸€ä¸ªå€™é€‰ï¼Œ 7 = 7 ã€‚
> 	- ä»…æœ‰è¿™ä¸¤ç§ç»„åˆã€‚
>     
>     
> ç¤ºä¾‹ 2ï¼š
> è¾“å…¥: candidates = [2,3,5], target = 8
> è¾“å‡º: [[2,2,2,2],[2,3,3],[3,5]]
> 
> ç¤ºä¾‹ 3ï¼š
> è¾“å…¥: candidates = [2], target = 1
> è¾“å‡º: []
> ```
>
> * æç¤ºï¼š
>   * 1 <= `candidates.length` <= 30
>   * 2 <= `candidates`[i] <= 40
>   * `candidates` çš„æ‰€æœ‰å…ƒç´  äº’ä¸ç›¸åŒ
>   * 1 <= `target` <= 40

### 2ã€æ€è·¯

![39.ç»„åˆæ€»å’Œ](https://code-thinking-1253855093.file.myqcloud.com/pics/20201223170730367-20230310135337214.png)

* æŠ½è±¡æ ‘çš„å®½åº¦ç”± `candidates` æ•°ç»„çš„é•¿åº¦å†³å®šï¼Œæ·±åº¦åˆ™æ ¹æ® `target` å˜åŒ–

### 3ã€ä»£ç 

```c
int **result;
int resultTop;
int *path;
int pathTop;
int *length;

void backTracking(int target,int index,int * candidates, int candidatesSize,int sum){
    if(sum >= target){
        if(sum == target){
            int* temp = (int*)malloc(sizeof(int)* pathTop);
            for(int i=0 ;i < pathTop; i++){
              temp[i] = path[i];
            }
        length[resultTop] = pathTop;
        result[resultTop++] = temp;
        
    }
        return ; 
    }
   
    // içš„èµ·å§‹ä¸ºindexï¼Œè¿™æ ·å°±ä¸ä¼šå‡ºç°æ•°å­—ç›¸åŒï¼Œä½†é¡ºåºä¸ç›¸åŒçš„æƒ…å†µ
    for(int i = index; i < candidatesSize; i++ ){
        path[pathTop++] = candidates[i];
        sum += candidates[i];
        backTracking(target,i,candidates,candidatesSize,sum);
        sum -= candidates[i];
        pathTop--;
    }

}


int** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){
    result = (int **)malloc(sizeof(int*)*151);
    path = (int*)malloc(sizeof(int)*target);
    length = (int*)malloc(sizeof(int)*200);
    resultTop = pathTop = 0;

    backTracking(target,0,candidates,candidatesSize,0);

    * returnSize = resultTop;
    * returnColumnSizes = (int* )malloc(sizeof(int)*resultTop);
    for(int i=0;i<resultTop;i++){
        (*returnColumnSizes)[i] = length[i];
    }
    return result;
}
```

## 6ã€ç»„åˆæ€»å’ŒII

[40. ç»„åˆæ€»å’Œ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/combination-sum-ii/)

### 1ã€é¢˜ç›®

> * ç»™å®šä¸€ä¸ªå€™é€‰äººç¼–å·çš„é›†åˆ `candidates` å’Œä¸€ä¸ªç›®æ ‡æ•° `target` ï¼Œæ‰¾å‡º `candidates` ä¸­æ‰€æœ‰å¯ä»¥ä½¿æ•°å­—å’Œä¸º `target` çš„ç»„åˆã€‚
> * `candidates` ä¸­çš„æ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ ä¸€æ¬¡ ã€‚
> * æ³¨æ„ï¼šè§£é›†ä¸èƒ½åŒ…å«é‡å¤çš„ç»„åˆã€‚ 
>
> ```c
> ç¤ºä¾‹Â 1:
> 
> è¾“å…¥: candidates =Â [10,1,2,7,6,1,5], target =Â 8,
> è¾“å‡º:
> [
> [1,1,6],
> [1,2,5],
> [1,7],
> [2,6]
> ]
> 
> ç¤ºä¾‹Â 2:
> è¾“å…¥: candidates =Â [2,5,2,1,2], target =Â 5,
> è¾“å‡º:
> [
> [1,2,2],
> [5]
> ]
> Â 
> ```
>
> * æç¤º :
>
>   1 <= `candidates.length` <= 100
>   1 <= `candidates`[i] <= 50
>   1 <= `target` <= 30

### 2ã€æ€è·¯

> * è¿™é“é¢˜ç›®å’Œ[39.ç»„åˆæ€»å’Œ (opens new window)](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)å¦‚ä¸‹åŒºåˆ«ï¼š
>   1. æœ¬é¢˜candidates ä¸­çš„æ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ä¸€æ¬¡ã€‚
>   2. æœ¬é¢˜æ•°ç»„candidatesçš„å…ƒç´ æ˜¯æœ‰é‡å¤çš„ï¼Œè€Œ[39.ç»„åˆæ€»å’Œ (opens new window)](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)æ˜¯æ— é‡å¤å…ƒç´ çš„æ•°ç»„candidates

* **ä¸»è¦çš„éš¾ç‚¹åœ¨äºåŒºåˆ«2ä¸­ï¼šé›†åˆï¼ˆæ•°ç»„candidatesï¼‰æœ‰é‡å¤å…ƒç´ ï¼Œä½†è¿˜ä¸èƒ½æœ‰é‡å¤çš„ç»„åˆ**ã€‚
  * å¦‚ï¼š[2,1,2]ï¼Œ[1,2,2] è¿™ç§æƒ…å†µæ˜¯ä¸å¯ä»¥çš„

* è¦è§£å†³è¿™ä¸ªé—®é¢˜æˆ‘ä»¬å°±è¦å¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œç„¶ååœ¨forå¾ªç¯é‡Œè¿›è¡Œåˆ¤æ–­ï¼ˆå› ä¸ºæˆ‘ä»¬è¦çš„æ˜¯æ ‘å±‚å»é‡ï¼‰ï¼Œå¦‚æœå½“å‰éå†ä¸‹æ ‡å¯¹åº”çš„å…ƒç´ ä¸ä¸Šä¸€æ¬¡éå†çš„å…ƒç´ ç›¸åŒï¼Œé‚£ä¹ˆè·³è¿‡è¯¥å±‚éå†ã€‚



### 3ã€ä»£ç 

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */

int ** result;
int resultTop;
int * path;
int pathTop;
int * lengths;
int cmp(const void* a1, const void* a2) {
    return *((int*)a1) - *((int*)a2);
}

void backtracking(int* candidates, int candidatesSize, int target,int sum,int index){
    if(sum >= target){
        if(sum == target){
            int* temp = (int*)malloc(sizeof(int)* pathTop);
            for(int i=0;i<pathTop;i++){
                temp[i] = path[i];
            }
            result[resultTop] = temp;
            lengths[resultTop++] = pathTop; 
        }
        return ;
    }

    for(int i = index;i < candidatesSize;i++){
        //å¯¹åŒä¸€å±‚æ ‘ä¸­ä½¿ç”¨è¿‡çš„å…ƒç´ è·³è¿‡
        if(i > index && candidates[i] == candidates[i-1])
            {continue;}
        sum += candidates[i];
        path[pathTop++] = candidates[i];
        backtracking(candidates,candidatesSize,target,sum,i+1);
        pathTop--;
        sum -= candidates[i];
    }
}
 
int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){

    result = (int **)malloc(sizeof(int*)*100);
    path = (int *)malloc(sizeof(int)* target);
    lengths = (int*)malloc(sizeof(int)* 100);
    resultTop = pathTop = 0;

    //å¿«é€Ÿæ’åºcandidatesï¼Œè®©ç›¸åŒå…ƒç´ æŒ¨åˆ°ä¸€èµ·
    qsort(candidates, candidatesSize, sizeof(int), cmp);

    backtracking(candidates,candidatesSize,target,0,0);
    
    * returnSize = resultTop;
    * returnColumnSizes = (int*)malloc(sizeof(int)* (*returnSize));
    for(int i=0;i<(*returnSize);i++){
       (* returnColumnSizes)[i] = lengths[i];
    }
    
    return result;

}
```

## 7ã€åˆ†å‰²å›æ–‡ä¸²

### 1ã€é¢˜ç›®

> * ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s`ï¼Œè¯·ä½ å°† `s` åˆ†å‰²æˆä¸€äº›å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯ **å›æ–‡ä¸²** ã€‚è¿”å› `s` æ‰€æœ‰å¯èƒ½çš„åˆ†å‰²æ–¹æ¡ˆã€‚
> * **å›æ–‡ä¸²** æ˜¯æ­£ç€è¯»å’Œåç€è¯»éƒ½ä¸€æ ·çš„å­—ç¬¦ä¸²ã€‚
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> è¾“å…¥ï¼šs = "aab"
> è¾“å‡ºï¼š[["a","a","b"],["aa","b"]]
> 
> ç¤ºä¾‹ 2ï¼š
> è¾“å…¥ï¼šs = "a"
> è¾“å‡ºï¼š[["a"]]
> ```
>
> * **æç¤ºï¼š**
>   - `1 <= s.length <= 16`
>   - `s` ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ

### 2ã€æ€è·¯

![131.åˆ†å‰²å›æ–‡ä¸²](https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg)



### 3ã€ä»£ç 

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
char** path;
int pathTop;
char*** ans;
int ansTop = 0;
int* ansSize;

//å°†pathä¸­çš„å­—ç¬¦ä¸²å…¨éƒ¨å¤åˆ¶åˆ°ansä¸­
void copy() {
    //åˆ›å»ºä¸€ä¸ªä¸´æ—¶tempPathä¿å­˜pathä¸­çš„å­—ç¬¦ä¸²
    char** tempPath = (char**)malloc(sizeof(char*) * pathTop);
    int i;
    for(i = 0; i < pathTop; i++) {
        tempPath[i] = path[i];
    }
    //ä¿å­˜tempPath
    ans[ansTop] = tempPath;
    //å°†å½“å‰pathçš„é•¿åº¦ï¼ˆpathTopï¼‰ä¿å­˜åœ¨ansSizeä¸­
    ansSize[ansTop++] = pathTop;
}

//åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦ä¸ºå›æ–‡å­—ç¬¦ä¸²
bool isPalindrome(char* str, int startIndex, int endIndex) {
    //åŒæŒ‡é’ˆæ³•ï¼šå½“endIndexï¼ˆå³æŒ‡é’ˆï¼‰çš„å€¼æ¯”startIndexï¼ˆå·¦æŒ‡é’ˆï¼‰å¤§æ—¶è¿›è¡Œéå†
    while(endIndex >= startIndex) {
        //è‹¥å·¦æŒ‡é’ˆå’Œå³æŒ‡é’ˆæŒ‡å‘å…ƒç´ ä¸ä¸€æ ·ï¼Œè¿”å›False
        if(str[endIndex--] != str[startIndex++])
            return 0;
    }
    return 1;
}

//åˆ‡å‰²ä»startIndexåˆ°endIndexå­å­—ç¬¦ä¸²
char* cutString(char* str, int startIndex, int endIndex) {
    //å¼€è¾Ÿå­—ç¬¦ä¸²çš„ç©ºé—´
    char* tempString = (char*)malloc(sizeof(char) * (endIndex - startIndex + 2));
    int i;
    int index = 0;
    //å¤åˆ¶å­å­—ç¬¦ä¸²
    for(i = startIndex; i <= endIndex; i++)
        tempString[index++] = str[i];
    //ç”¨'\0'ä½œä¸ºå­—ç¬¦ä¸²ç»“å°¾
    tempString[index] = '\0';
    return tempString;
}

void backTracking(char* str, int strLen,  int startIndex) {
    if(startIndex >= strLen) {
        //å°†pathæ‹·è´åˆ°ansä¸­
        copy();
        return ;
    }

    int i;
    for(i = startIndex; i < strLen; i++) {
        //è‹¥ä»subStringåˆ°içš„å­ä¸²æ˜¯å›æ–‡å­—ç¬¦ä¸²ï¼Œå°†å…¶æ”¾å…¥pathä¸­
        if(isPalindrome(str, startIndex, i)) {
            path[pathTop++] = cutString(str, startIndex, i);
        }
        //è‹¥ä»startIndexåˆ°içš„å­ä¸²ä¸ä¸ºå›æ–‡å­—ç¬¦ä¸²ï¼Œè·³è¿‡è¿™ä¸€å±‚ 
        else {
            continue;
        }
        //é€’å½’åˆ¤æ–­ä¸‹ä¸€å±‚
        backTracking(str, strLen, i + 1);
        //å›æº¯ï¼Œå°†pathä¸­æœ€åä¸€ä½å…ƒç´ å¼¹å‡º
        pathTop--;
    }
}

char*** partition(char* s, int* returnSize, int** returnColumnSizes){
    int strLen = strlen(s);
    //å› ä¸ºpathä¸­çš„å­—ç¬¦ä¸²æœ€å¤šä¸ºstrLenä¸ªï¼ˆå³å•ä¸ªå­—ç¬¦çš„å›æ–‡å­—ç¬¦ä¸²ï¼‰ï¼Œæ‰€ä»¥å¼€è¾ŸstrLenä¸ªchar*ç©ºé—´
    path = (char**)malloc(sizeof(char*) * strLen);
    //å­˜æ”¾pathä¸­çš„æ•°ç»„ç»“æœ
    ans = (char***)malloc(sizeof(char**) * 40000);
    //å­˜æ”¾ansæ•°ç»„ä¸­æ¯ä¸€ä¸ªchar**æ•°ç»„çš„é•¿åº¦
    ansSize = (int*)malloc(sizeof(int) * 40000);
    ansTop = pathTop = 0;

    //å›æº¯å‡½æ•°
    backTracking(s, strLen, 0);

    //å°†ansTopè®¾ç½®ä¸ºansæ•°ç»„çš„é•¿åº¦
    *returnSize = ansTop;
    //è®¾ç½®ansæ•°ç»„ä¸­æ¯ä¸€ä¸ªæ•°ç»„çš„é•¿åº¦
    *returnColumnSizes = (int*)malloc(sizeof(int) * ansTop);
    int i;
    for(i = 0; i < ansTop; ++i) {
        (*returnColumnSizes)[i] = ansSize[i];
    }
    return ans;
}
```

## 8ã€å¤åŸIPåœ°å€

[93. å¤åŸ IP åœ°å€ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/restore-ip-addresses/submissions/)

### 1ã€é¢˜ç›®

> * **æœ‰æ•ˆ IP åœ°å€** æ­£å¥½ç”±å››ä¸ªæ•´æ•°ï¼ˆæ¯ä¸ªæ•´æ•°ä½äº `0` åˆ° `255` ä¹‹é—´ç»„æˆï¼Œä¸”ä¸èƒ½å«æœ‰å‰å¯¼ `0`ï¼‰ï¼Œæ•´æ•°ä¹‹é—´ç”¨ `'.'` åˆ†éš”ã€‚
>   * ä¾‹å¦‚ï¼š"`0.1.2.201`" å’Œ "`192.168.1.1`" æ˜¯ æœ‰æ•ˆ `IP` åœ°å€
>   * ä½†æ˜¯ "`0.011.255.245`"ã€"`192.168.1.312`" å’Œ "`192.168@1.1`" æ˜¯ **æ— æ•ˆ** `IP` åœ°å€ã€‚
> * ç»™å®šä¸€ä¸ªåªåŒ…å«æ•°å­—çš„å­—ç¬¦ä¸² `s` ï¼Œç”¨ä»¥è¡¨ç¤ºä¸€ä¸ª `IP` åœ°å€ï¼Œè¿”å›æ‰€æœ‰å¯èƒ½çš„**æœ‰æ•ˆ `IP` åœ°å€**ï¼Œè¿™äº›åœ°å€å¯ä»¥é€šè¿‡åœ¨ `s` ä¸­æ’å…¥ `'.'` æ¥å½¢æˆã€‚ä½  **ä¸èƒ½ é‡æ–°æ’åºæˆ–åˆ é™¤** `s` ä¸­çš„ä»»ä½•æ•°å­—ã€‚ä½ å¯ä»¥æŒ‰ **ä»»ä½•é¡ºåº**è¿”å›ç­”æ¡ˆã€‚
>
> ```C
> ç¤ºä¾‹ 1ï¼š
> è¾“å…¥ï¼šs = "25525511135"
> è¾“å‡ºï¼š["255.255.11.135","255.255.111.35"]
>     
> ç¤ºä¾‹ 2ï¼š
> è¾“å…¥ï¼šs = "0000"
> è¾“å‡ºï¼š["0.0.0.0"]
>     
> ç¤ºä¾‹ 3ï¼š
> è¾“å…¥ï¼šs = "101023"
> è¾“å‡ºï¼š["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
> ```
>
> * **æç¤ºï¼š**
>   - `1 <= s.length <= 20`
>   - `s` ä»…ç”±æ•°å­—ç»„æˆ

### 2ã€æ€è·¯

![93.å¤åŸIPåœ°å€](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933.png)

### 3ã€ä»£ç 

```c

// è®°å½•ç»“æœ
char ** result;
int resultTop;

//è®°å½•åº”è¯¥åŠ å…¥'.'çš„ä½ç½®
int segments[3];
// åˆ¤æ–­åŠ å…¥å­—ç¬¦æ˜¯å¦åˆæ³•
int isValid(char* s,int start,int end){
    if(start > end){
        return 0;
    }
    if(s[start] == '0' && start != end){
        return false;
    }
    int num =0;
    for(int i = start;i <= end;i++){
        // åˆ¤æ–­æ˜¯å¦å‡ºç°éæ³•å­—ç¬¦
        if(s[i] > '9' || s[i] < '0'){
            return false;
        }
        num = num * 10 + (s[i] - '0');
        //å¦‚æœå¤§äº255äº†ä¸åˆæ³•
        if(num > 255){ 
            return false;
        }
    }
    return true;
}


//startIndexä¸ºèµ·å§‹æœç´¢ä½ç½®ï¼ŒpointNumä¸º'.'å¯¹è±¡
void backTracking(char* s, int startIndex, int pointNum) {
    //è‹¥'.'æ•°é‡ä¸º3ï¼Œåˆ†éš”ç»“æŸ
    if(pointNum == 3) {
        //è‹¥æœ€åä¸€æ®µå­—ç¬¦ä¸²ç¬¦åˆè¦æ±‚ï¼Œå°†å½“å‰çš„å­—ç¬¦ä¸²æ”¾å…¥resultç§
        if(isValid(s, startIndex, strlen(s) - 1)) {
            char* tempString = (char*)malloc(sizeof(char) * strlen(s) + 4);
            int j;
            //è®°å½•æ·»åŠ å­—ç¬¦æ—¶tempStringçš„ä¸‹æ ‡
            int count = 0;
            //è®°å½•æ·»åŠ å­—ç¬¦æ—¶'.'çš„ä½¿ç”¨æ•°é‡
            int count1 = 0;
            for(j = 0; j < strlen(s); j++) {
                tempString[count++] = s[j];
                //è‹¥'.'çš„ä½¿ç”¨æ•°é‡å°äº3ä¸”å½“å‰ä¸‹æ ‡ç­‰äº'.'ä¸‹æ ‡ï¼Œæ·»åŠ '.'åˆ°æ•°ç»„
                if(count1 < 3 && j == segments[count1]) {
                    tempString[count++] = '.';
                    count1++;
                }
            }
            tempString[count] = 0;
            //æ‰©å®¹resultæ•°ç»„
            result = (char**)realloc(result, sizeof(char*) * (resultTop + 1));
            result[resultTop++] = tempString;
        }
        return ;
    }

    int i;
    for(i = startIndex; i < strlen(s); i++) {
        if(isValid(s, startIndex, i)) {
            //è®°å½•åº”è¯¥æ·»åŠ '.'çš„ä½ç½®
            segments[pointNum] = i;
            backTracking(s, i + 1, pointNum + 1);
        }
        else {
            break;
        }
    }
}

char ** restoreIpAddresses(char * s, int* returnSize){
    result =(char**)malloc(0);
    resultTop = 0;
    backTracking(s,0,0);
    *returnSize = resultTop;
    return result;
}
```

## 9ã€å­é›†

[78. å­é›† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/subsets/)

### 1ã€é¢˜ç›®

> * ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œæ•°ç»„ä¸­çš„å…ƒç´  **äº’ä¸ç›¸åŒ** ã€‚è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚
> * è§£é›† **ä¸èƒ½** åŒ…å«é‡å¤çš„å­é›†ã€‚ä½ å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›è§£é›†ã€‚
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> è¾“å…¥ï¼šnums = [1,2,3]
> è¾“å‡ºï¼š[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
> 
> ç¤ºä¾‹ 2ï¼š
> è¾“å…¥ï¼šnums = [0]
> è¾“å‡ºï¼š[[],[0]]
> ```
>
> **æç¤ºï¼š**
>
> - `1 <= nums.length <= 10`
> - `-10 <= nums[i] <= 10`
> - `nums` ä¸­çš„æ‰€æœ‰å…ƒç´  **äº’ä¸ç›¸åŒ**

### 2ã€æ€è·¯

![78.å­é›†](https://code-thinking.cdn.bcebos.com/pics/78.%E5%AD%90%E9%9B%86.png)

* ä»å›¾ä¸­çº¢çº¿éƒ¨åˆ†ï¼Œå¯ä»¥çœ‹å‡º**éå†è¿™ä¸ªæ ‘çš„æ—¶å€™ï¼ŒæŠŠæ‰€æœ‰èŠ‚ç‚¹éƒ½è®°å½•ä¸‹æ¥ï¼Œå°±æ˜¯è¦æ±‚çš„å­é›†é›†åˆ**ã€‚

### 3ã€ä»£ç 

```c
int* path;
int pathTop;
int** ans;
int ansTop;
//è®°å½•äºŒç»´æ•°ç»„ä¸­æ¯ä¸ªä¸€ç»´æ•°ç»„çš„é•¿åº¦
int* length;
//å°†å½“å‰pathæ•°ç»„å¤åˆ¶åˆ°ansä¸­
void copy() {
    int* tempPath = (int*)malloc(sizeof(int) * pathTop);
    int i;
    for(i = 0; i < pathTop; i++) {
        tempPath[i] = path[i];
    }
    ans = (int**)realloc(ans, sizeof(int*) * (ansTop+1));
    length[ansTop] = pathTop;
    ans[ansTop++] = tempPath;
}

void backTracking(int* nums, int numsSize, int startIndex) {
    //æ”¶é›†å­é›†ï¼Œè¦æ”¾åœ¨ç»ˆæ­¢æ·»åŠ çš„ä¸Šé¢ï¼Œå¦åˆ™ä¼šæ¼æ‰è‡ªå·±
    copy();
    //è‹¥startIndexå¤§äºæ•°ç»„å¤§å°ï¼Œè¿”å›
    if(startIndex >= numsSize) {
        return;
    }
    int j;
    for(j = startIndex; j < numsSize; j++) {
        //å°†å½“å‰ä¸‹æ ‡æ•°å­—æ”¾å…¥pathä¸­
        path[pathTop++] = nums[j];
        backTracking(nums, numsSize, j+1);
        //å›æº¯
        pathTop--;
    }
}

int** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    //åˆå§‹åŒ–è¾…åŠ©å˜é‡
    path = (int*)malloc(sizeof(int) * numsSize);
    ans = (int**)malloc(0);
    length = (int*)malloc(sizeof(int) * 1500);
    ansTop = pathTop = 0;
    //è¿›å…¥å›æº¯
    backTracking(nums, numsSize, 0);
    //è®¾ç½®äºŒç»´æ•°ç»„ä¸­å…ƒç´ ä¸ªæ•°
    *returnSize = ansTop;
    //è®¾ç½®äºŒç»´æ•°ç»„ä¸­æ¯ä¸ªä¸€ç»´æ•°ç»„çš„é•¿åº¦
    *returnColumnSizes = (int*)malloc(sizeof(int) * ansTop);
    int i;
    for(i = 0; i < ansTop; i++) {
        (*returnColumnSizes)[i] = length[i];
    }
    return ans;
}
```

## 10ã€å­é›†II

[90. å­é›† II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/subsets-ii/)

### 1ã€é¢˜ç›®

> * ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œå…¶ä¸­å¯èƒ½åŒ…å«é‡å¤å…ƒç´ ï¼Œè¯·ä½ è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚
> * è§£é›† **ä¸èƒ½** åŒ…å«é‡å¤çš„å­é›†ã€‚è¿”å›çš„è§£é›†ä¸­ï¼Œå­é›†å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** æ’åˆ—ã€‚
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> è¾“å…¥ï¼šnums = [1,2,2]
> è¾“å‡ºï¼š[[],[1],[1,2],[1,2,2],[2],[2,2]]
> 
> ç¤ºä¾‹ 2ï¼š
> è¾“å…¥ï¼šnums = [0]
> è¾“å‡ºï¼š[[],[0]]
> ```
>
> * **æç¤ºï¼š**
>   - `1 <= nums.length <= 10`
>   - `-10 <= nums[i] <= 10`

### 2ã€æ€è·¯

![90.å­é›†II](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124195411977.png)

* å’Œ **9ã€å­é›† **  å¯¹æ¯”ï¼Œæœ¬é¢˜çš„åŒºåˆ«åœ¨äºç»™å®šæˆ‘ä»¬çš„æ•°ç»„ä¸­çš„å…ƒç´ ä¸å†æ˜¯å”¯ä¸€çš„ï¼Œå¯èƒ½å‡ºç°å…ƒç´ ç›¸åŒçš„æƒ…å†µï¼Œæ‰€ä»¥æˆ‘ä»¬è¦é€šè¿‡æ’åºå†åŠ "æ ‘å±‚å»é‡"æ¥è¿›è¡Œå›æº¯

### 3ã€ä»£ç 

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int ** result;
int * path;
int resultTop;
int pathTop;
int* lengths;
int cmp(const void* a1, const void* a2) {
    return *((int*)a1) - *((int*)a2);
}
void copy(){
    int* temp = (int*)malloc(sizeof(int)* pathTop);
    for(int i=0; i< pathTop;i++){
        temp[i] = path[i];
    }
    result= (int**)realloc(result, sizeof(int*) * (resultTop+1));
    result[resultTop] = temp;
    lengths[resultTop++] = pathTop;
    return;
}

void backTracking(int *nums,int numsSize,int startIndex){
    copy();
    if(startIndex >= numsSize){
        return ;
    }

    for(int i =startIndex; i < numsSize; i++ ){
        // åŒå±‚å»é‡
        if(i >startIndex && nums[i-1] == nums[i]){
            continue;
        }
        path[pathTop++] = nums[i];
        backTracking(nums,numsSize,i+1);
        pathTop--;
    }
}
 
int** subsetsWithDup(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    
    result = (int**)malloc(0);
    path = (int*)malloc(sizeof(int)* numsSize);
    lengths = (int*) malloc(sizeof(int)* 1500);
    resultTop = pathTop = 0;
    //å¿«é€Ÿæ’åºcandidatesï¼Œè®©ç›¸åŒå…ƒç´ æŒ¨åˆ°ä¸€èµ·
    qsort(nums, numsSize, sizeof(int), cmp);
    backTracking(nums,numsSize,0);

    * returnSize = resultTop ;
    * returnColumnSizes = (int*)malloc(sizeof(int)* resultTop);
    for(int i=0; i < resultTop;i++){
        (*returnColumnSizes)[i] = lengths[i];
    }

    return result;
}
```

 

## 11ã€é€’å¢å­åºåˆ—

[491. é€’å¢å­åºåˆ— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/non-decreasing-subsequences/)

### 1ã€é¢˜ç›®

> * ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾å‡ºå¹¶è¿”å›æ‰€æœ‰è¯¥æ•°ç»„ä¸­ä¸åŒçš„é€’å¢å­åºåˆ—ï¼Œé€’å¢å­åºåˆ—ä¸­ **è‡³å°‘æœ‰ä¸¤ä¸ªå…ƒç´ ** ã€‚ä½ å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›ç­”æ¡ˆã€‚
> * æ•°ç»„ä¸­å¯èƒ½å«æœ‰é‡å¤å…ƒç´ ï¼Œå¦‚å‡ºç°ä¸¤ä¸ªæ•´æ•°ç›¸ç­‰ï¼Œä¹Ÿå¯ä»¥è§†ä½œé€’å¢åºåˆ—çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µã€‚
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> è¾“å…¥ï¼šnums = [4,6,7,7]
> è¾“å‡ºï¼š[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
>     
> ç¤ºä¾‹ 2ï¼š
> è¾“å…¥ï¼šnums = [4,4,3,2,1]
> è¾“å‡ºï¼š[[4,4]]
> ```
>
> * **æç¤ºï¼š**
>   - `1 <= nums.length <= 15`
>   - `-100 <= nums[i] <= 100`

### 2ã€æ€è·¯

* è¿™é¢˜æˆ‘é¢˜ç›®éƒ½æ²¡æ€ä¹ˆçœ‹æ‡‚äº†ğŸ˜­ï¼Œè‡ªå·±æœ¬æ¥å†™äº†è¿™æ ·çš„ä»£ç ï¼š

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */

int** result;
int *path;
int resultTop;
int pathTop;
int* lengths;

void copy(){
    int* temp = (int*)malloc(sizeof(int)* pathTop);
    for(int i=0;i < pathTop;i++){
        temp[i] = path[i];
    }

    result[resultTop] = temp;
    lengths[resultTop++] = pathTop;
    return ;
}

void backTracking(int * nums,int numsSize,int startIndex){
    if(pathTop > 1){
        copy();
    }
    if(pathTop > numsSize){
        return ;
    }

    for(int i= startIndex;i < numsSize ; i++){
        if( i > startIndex && nums[i-1] == nums[i]){
            continue;
        }
        if( pathTop>0 && path[pathTop-1] > nums[i]){
            continue;
        }
        path[pathTop++] = nums[i];
        backTracking(nums,numsSize,i+1);
        pathTop--;
    }
}



int** findSubsequences(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    
    result = (int**)malloc(sizeof(int*)*33000);
    path = (int*)malloc(sizeof(int)* numsSize);
    lengths = (int*)malloc(sizeof(int)* 33000);
    resultTop = pathTop =0;
    backTracking(nums,numsSize,0);
    * returnSize = resultTop;
    * returnColumnSizes = (int*)malloc(sizeof(int)* resultTop);
    for(int i=0; i < resultTop;i++){
        (*returnColumnSizes)[i] = lengths[i];
    }
    return result;
}
```

* ä½†æ˜¯æ‰§è¡Œ `[1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]`æµ‹è¯•ä¾‹å­æ—¶ï¼Œå°±é”™è¯¯äº†ï¼Œç»“æœé‡Œé¢å¤šå‡ºäº† `[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1]`ï¼Œè¿™å‡ ä¸ªç»“æœï¼ˆæˆ‘è‡ªå·±ç†è§£é¢˜ç›®çš„è¯ï¼Œä¹Ÿæ˜¯æœ‰è¿™å‡ ä¸ªç­”æ¡ˆçš„ï¼‰ï¼Œå› ä¸ºæˆ‘è‡ªå·±æ²¡æ€ä¹ˆç†è§£é¢˜ç›®ï¼Œæ‰€ä»¥å°±è‡ªå·±æ”¾éšæƒ³å½•äº†é¢˜è§£äº†
* [ä»£ç éšæƒ³å½• (programmercarl.com)](https://www.programmercarl.com/0491.é€’å¢å­åºåˆ—.html#æ€è·¯)

## 12ã€å…¨æ’åˆ—

[46. å…¨æ’åˆ— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/permutations/)

### 1ã€é¢˜ç›®

> * ç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„ nums ï¼Œè¿”å›å…¶ æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ— ã€‚ä½ å¯ä»¥ **æŒ‰ä»»æ„é¡ºåº** è¿”å›ç­”æ¡ˆã€‚
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> 
> è¾“å…¥ï¼šnums = [1,2,3]
> è¾“å‡ºï¼š[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ç¤ºä¾‹ 2ï¼š
> 
> è¾“å…¥ï¼šnums = [0,1]
> è¾“å‡ºï¼š[[0,1],[1,0]]
> ç¤ºä¾‹ 3ï¼š
> 
> è¾“å…¥ï¼šnums = [1]
> è¾“å‡ºï¼š[[1]]
> ```
>
> * **æç¤ºï¼š**
>   - `1 <= nums.length <= 6`
>   - `-10 <= nums[i] <= 10`
>   - `nums` ä¸­çš„æ‰€æœ‰æ•´æ•° **äº’ä¸ç›¸åŒ**



### 2ã€æ€è·¯

![46.å…¨æ’åˆ—](https://code-thinking-1253855093.file.myqcloud.com/pics/20201209174225145.png)

* è¿™é¢˜ä¸»è¦å°±æ˜¯è¦åˆ¤æ–­å…ƒç´ æ˜¯å¦è¢«ä½¿ç”¨è¿‡ï¼Œéšæƒ³å½•æ˜¯åˆ›å»ºäº†ä¸€ä¸ªæ•°ç»„æŒ‰ä¸‹æ ‡è®°å½•å¯¹åº”ä½ç½®å…ƒç´ æ˜¯å¦è¢«ä½¿ç”¨ï¼Œï¼ˆæˆ‘è‡ªå·±åˆ™æ˜¯æ¯æ¬¡éå†å…ƒç´ éƒ½è¿›è¡Œåˆ¤æ–­ï¼ŒæŸ¥çœ‹å…ƒç´ æ˜¯å¦åœ¨ pathæ•°ç»„é‡Œï¼Œæ˜¯è¯´æ˜è¢«ä½¿ç”¨ï¼‰

### 3ã€ä»£ç 

* ä¸‹é¢è¿™ä¸ªæ˜¯è‡ªå·±å†™çš„ä»£ç ï¼š

```c
int** result;
int * path;
int pathTop;
int resultTop;
int * lengths;

void copy(){
    int* temp = (int*)malloc(sizeof(int)*pathTop);
    for(int i=0;i<pathTop;i++){
        temp[i] = path[i];
    }
    result[resultTop++] = temp;
    return ;
}

int find(int key){
    for(int i=0;i<pathTop;i++){
        if(key == path[i]){
            return 1;  //å·²ä½¿ç”¨
        }       
    }
    return 0;  //æœªè¢«ä½¿ç”¨
}

void backTracking(int* nums, int numsSize){
    if(pathTop == numsSize){
        copy();
        return ;
    }
    for(int i =0;i<numsSize;i++){
        if(find(nums[i])){
            continue;
        }
        path[pathTop++] = nums[i];
        backTracking(nums,numsSize);
        pathTop--;
    }

}

int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    result = (int**)malloc(sizeof(int*)*1000);
    path = (int *)malloc(sizeof(int)* numsSize);
    pathTop = resultTop =0;

    backTracking(nums,numsSize);

    *returnSize = resultTop;
    *returnColumnSizes = (int*)malloc(sizeof(int)*resultTop);
    for(int i =0 ;i<resultTop;i++){
        (*returnColumnSizes)[i]= numsSize;
    }
    return result;
}
```

* çœ‹äº†éšæƒ³å½•çš„ï¼Œæ„Ÿè§‰æ¯”è‡ªå·±å†™çš„å¥½ğŸ˜­

```c
int* path;
int pathTop;
int** ans;
int ansTop;

//å°†usedä¸­å…ƒç´ éƒ½è®¾ç½®ä¸º0
void initialize(int* used, int usedLength) {
    int i;
    for(i = 0; i < usedLength; i++) {
        used[i] = 0;
    }
}

//å°†pathä¸­å…ƒç´ æ‹·è´åˆ°ansä¸­
void copy() {
    int* tempPath = (int*)malloc(sizeof(int) * pathTop);
    int i;
    for(i = 0; i < pathTop; i++) {
        tempPath[i] = path[i];
    }
    ans[ansTop++] = tempPath;
}

void backTracking(int* nums, int numsSize, int* used) {
    //è‹¥pathä¸­å…ƒç´ ä¸ªæ•°ç­‰äºnumså…ƒç´ ä¸ªæ•°ï¼Œå°†numsæ”¾å…¥ansä¸­
    if(pathTop == numsSize) {
        copy();
        return;
    }
    int i;
    for(i = 0; i < numsSize; i++) {
        //è‹¥å½“å‰ä¸‹æ ‡ä¸­å…ƒç´ å·²ä½¿ç”¨è¿‡ï¼Œåˆ™è·³è¿‡å½“å‰å…ƒç´ 
        if(used[i])
            continue;
        used[i] = 1;
        path[pathTop++] = nums[i];
        backTracking(nums, numsSize, used);
        //å›æº¯
        pathTop--;
        used[i] = 0;
    }
}

int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    //åˆå§‹åŒ–è¾…åŠ©å˜é‡
    path = (int*)malloc(sizeof(int) * numsSize);
    ans = (int**)malloc(sizeof(int*) * 1000);
    int* used = (int*)malloc(sizeof(int) * numsSize);
    //å°†usedæ•°ç»„ä¸­å…ƒç´ éƒ½ç½®0
    initialize(used, numsSize);
    ansTop = pathTop = 0;

    backTracking(nums, numsSize, used);

    //è®¾ç½®pathå’Œansæ•°ç»„çš„é•¿åº¦
    *returnSize = ansTop;
    *returnColumnSizes = (int*)malloc(sizeof(int) * ansTop);
    int i;
    for(i = 0; i < ansTop; i++) {
        (*returnColumnSizes)[i] = numsSize;
    }
    return ans;
}
```



### 13ã€å…¨æ’åˆ—II

[47. å…¨æ’åˆ— II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/permutations-ii/)

### 1ã€é¢˜ç›®

> * ç»™å®šä¸€ä¸ªå¯åŒ…å«é‡å¤æ•°å­—çš„åºåˆ— nums ï¼ŒæŒ‰ä»»æ„é¡ºåº è¿”å›æ‰€æœ‰ä¸é‡å¤çš„å…¨æ’åˆ—ã€‚
>
> ```c
> ç¤ºä¾‹ 1ï¼š
> è¾“å…¥ï¼šnums = [1,1,2]
> è¾“å‡ºï¼š
> [[1,1,2],
>  [1,2,1],
>  [2,1,1]]
>     
> ç¤ºä¾‹ 2ï¼š
> è¾“å…¥ï¼šnums = [1,2,3]
> è¾“å‡ºï¼š[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```
>
> 
>
> * æç¤ºï¼š
>   * 1 <= `nums.length` <= 8
>   * -10 <= `nums`[i] <= 10



### 2ã€æ€è·¯

* è¿™é“é¢˜ç›®å’Œ[46.å…¨æ’åˆ— (opens new window)](https://programmercarl.com/0046.å…¨æ’åˆ—.html)çš„åŒºåˆ«åœ¨ä¸**ç»™å®šä¸€ä¸ªå¯åŒ…å«é‡å¤æ•°å­—çš„åºåˆ—**ï¼Œè¦è¿”å›**æ‰€æœ‰ä¸é‡å¤çš„å…¨æ’åˆ—**ã€‚

* **è¿˜è¦å¼ºè°ƒçš„æ˜¯å»é‡ä¸€å®šè¦å¯¹å…ƒç´ è¿›è¡Œæ’åºï¼Œè¿™æ ·æˆ‘ä»¬æ‰æ–¹ä¾¿é€šè¿‡ç›¸é‚»çš„èŠ‚ç‚¹æ¥åˆ¤æ–­æ˜¯å¦é‡å¤ä½¿ç”¨äº†**ã€‚
* ä»¥ç¤ºä¾‹ä¸­çš„ [1,1,2]ä¸ºä¾‹ ï¼ˆä¸ºäº†æ–¹ä¾¿ä¸¾ä¾‹ï¼Œå·²ç»æ’åºï¼‰æŠ½è±¡ä¸ºä¸€æ£µæ ‘ï¼Œå»é‡è¿‡ç¨‹å¦‚å›¾ï¼š

![47.å…¨æ’åˆ—II1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201331223.png)

* å›¾ä¸­æˆ‘ä»¬å¯¹åŒä¸€æ ‘å±‚ï¼Œå‰ä¸€ä½ï¼ˆä¹Ÿå°±æ˜¯nums[i-1]ï¼‰å¦‚æœä½¿ç”¨è¿‡ï¼Œé‚£ä¹ˆå°±è¿›è¡Œå»é‡ã€‚

  **ä¸€èˆ¬æ¥è¯´ï¼šç»„åˆé—®é¢˜å’Œæ’åˆ—é—®é¢˜æ˜¯åœ¨æ ‘å½¢ç»“æ„çš„å¶å­èŠ‚ç‚¹ä¸Šæ”¶é›†ç»“æœï¼Œè€Œå­é›†é—®é¢˜å°±æ˜¯å–æ ‘ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„ç»“æœ**ã€‚



### 3ã€ä»£ç 

```c
//ä¸´æ—¶æ•°ç»„
int *path;
//è¿”å›æ•°ç»„
int **ans;
int *used;
int pathTop, ansTop;

//æ‹·è´pathåˆ°ansä¸­
void copyPath() {
    int *tempPath = (int*)malloc(sizeof(int) * pathTop);
    int i;
    for(i = 0; i < pathTop; ++i) {
        tempPath[i] = path[i];
    }
    ans[ansTop++] = tempPath;
}

void backTracking(int* used, int *nums, int numsSize) {
    //è‹¥pathä¸­å…ƒç´ ä¸ªæ•°ç­‰äºnumsSizeï¼Œå°†pathæ‹·è´å…¥ansæ•°ç»„ä¸­
    if(pathTop == numsSize)
        copyPath();
    int i;
    for(i = 0; i < numsSize; i++) {
        //è‹¥å½“å‰å…ƒç´ å·²è¢«ä½¿ç”¨
        //æˆ–å‰ä¸€ä½å…ƒç´ ä¸å½“å‰å…ƒç´ å€¼ç›¸åŒä½†å¹¶æœªè¢«ä½¿ç”¨
        //åˆ™è·³è¿‡æ­¤åˆ†æ”¯
        if(used[i] || (i != 0 && nums[i] == nums[i-1] && used[i-1] == 0))
            continue;

        //å°†å½“å‰å…ƒç´ çš„ä½¿ç”¨æƒ…å†µè®¾ä¸ºTrue
        used[i] = 1;
        path[pathTop++] = nums[i];
        backTracking(used, nums, numsSize);
        used[i] = 0;
        --pathTop;
    }
}

int cmp(void* elem1, void* elem2) {
    return *((int*)elem1) - *((int*)elem2);
}

int** permuteUnique(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    //æ’åºæ•°ç»„
    qsort(nums, numsSize, sizeof(int), cmp);
    //åˆå§‹åŒ–è¾…åŠ©å˜é‡
    pathTop = ansTop = 0;
    path = (int*)malloc(sizeof(int) * numsSize);
    ans = (int**)malloc(sizeof(int*) * 1000);
    //åˆå§‹åŒ–usedè¾…åŠ©æ•°ç»„
    used = (int*)malloc(sizeof(int) * numsSize);
    int i;
    for(i = 0; i < numsSize; i++) {
        used[i] = 0;
    }

    backTracking(used, nums, numsSize);

    //è®¾ç½®è¿”å›çš„æ•°ç»„çš„é•¿åº¦
    *returnSize = ansTop;
    *returnColumnSizes = (int*)malloc(sizeof(int) * ansTop);
    int z;
    for(z = 0; z < ansTop; z++) {
        (*returnColumnSizes)[z] = numsSize;
    }
    return ans;
}
```

4ã€æ‹“å±•

* è¯¦è§[ä»£ç éšæƒ³å½• (programmercarl.com)](https://www.programmercarl.com/0047.å…¨æ’åˆ—II.html#æ‹“å±•)
