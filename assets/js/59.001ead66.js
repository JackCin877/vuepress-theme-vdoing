(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{386:function(_,v,t){"use strict";t.r(v);var i=t(3),s=Object(i.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"进程概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程概述"}},[_._v("#")]),_._v(" 进程概述")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://www.jianshu.com/p/42cf3a246c18",target:"_blank",rel:"noopener noreferrer"}},[_._v("进程的定义、组成、组成形式和特征 - 简书 (jianshu.com)"),v("OutboundLink")],1)]),_._v(" "),v("h2",{attrs:{id:"_1、程序和进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、程序和进程"}},[_._v("#")]),_._v(" 1、程序和进程")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程")]),_._v("：")]),_._v(" "),v("blockquote",[v("ul",[v("li",[v("strong",[_._v("二进制格式标识")]),_._v("：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）")]),_._v(" "),v("li",[v("strong",[_._v("机器语言指令")]),_._v("：对程序算法进行编码。")]),_._v(" "),v("li",[v("strong",[_._v("程序入口地址")]),_._v("：标识程序开始执行时的起始指令位置。")]),_._v(" "),v("li",[v("strong",[_._v("数据")]),_._v("：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。")]),_._v(" "),v("li",[v("strong",[_._v("符号表及重定位表")]),_._v("：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。")]),_._v(" "),v("li",[v("strong",[_._v("共享库和动态链接信息")]),_._v("：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。")]),_._v(" "),v("li",[v("strong",[_._v("其他信息")]),_._v("：程序文件还包含许多其他信息，用以描述如何创建进程。")]),_._v(" "),v("li",[v("strong",[_._v("进程是正在运行的程序的实例")]),_._v("。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。")]),_._v(" "),v("li",[_._v("可以用一个程序来创建多个进程，"),v("strong",[_._v("进程是由内核定义的抽象实体")]),_._v("，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，"),v("strong",[_._v("进程由用户内存空间和一系列内核数据结构组成")]),_._v("，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。")])])])]),_._v(" "),v("li",[v("p",[_._v("程序是文件，会占用磁盘的空间，但是不占用系统的其他资源，如：内存，cpu")])]),_._v(" "),v("li",[v("p",[_._v("进程会占用内存和cpu资源")])]),_._v(" "),v("li",[v("p",[_._v("程序要想运行，那么操作系统必须给他分配程序执行所需要的资源，比如内存，cpu，可以理解为进程就是操作系统为我们程序运行所分配的资源")])])]),_._v(" "),v("h2",{attrs:{id:"_2、单道、多道程序设计"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、单道、多道程序设计"}},[_._v("#")]),_._v(" 2、单道、多道程序设计")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("单道程序，即在计算机内存中只允许一个的程序运行")]),_._v("。")])]),_._v(" "),v("li",[v("p",[_._v("多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。"),v("strong",[_._v("引入多道程序设计技术的根本目的是为了提高 CPU 的利用率")]),_._v("。")])]),_._v(" "),v("li",[v("p",[_._v("对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就"),v("strong",[_._v("微观")]),_._v("而言，"),v("strong",[_._v("任意时刻，CPU 上运行的程序只有一个")]),_._v("。")])]),_._v(" "),v("li",[v("p",[_._v("在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。")])])]),_._v(" "),v("h2",{attrs:{id:"_3、时间片"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、时间片"}},[_._v("#")]),_._v(" 3、时间片")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("时间片")]),_._v("（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”"),v("strong",[_._v("是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间")]),_._v("。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。")])]),_._v(" "),v("li",[v("p",[_._v("**时间片由操作系统内核的调度程序分配给每个进程。**首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。")])])]),_._v(" "),v("h2",{attrs:{id:"_4、并行与并发"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、并行与并发"}},[_._v("#")]),_._v(" 4、并行与并发")]),_._v(" "),v("ul",[v("li",[_._v("并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。")]),_._v(" "),v("li",[_._v("并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jackcin877.github.io/image-hosting/Linux/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.73834ajx3w00.webp",alt:"并发与并行"}})]),_._v(" "),v("h2",{attrs:{id:"_5、-进程控制块-pcb"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5、-进程控制块-pcb"}},[_._v("#")]),_._v(" 5、 进程控制块（PCB）")]),_._v(" "),v("ul",[v("li",[_._v("为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。"),v("strong",[_._v("内核为每个进程分配一个 PCB(Processing Control Block)进程控制块")]),_._v("，维护进程相关的信息，"),v("strong",[_._v("Linux 内核的进程控制块是 task_struct 结构体")]),_._v("。")]),_._v(" "),v("li",[_._v("在 /usr/src/linux-headers-xxx/include/linux/sched.h 文件中可以查看 struct task_struct 结构体定义。其内部成员有很多，我们只需要掌握以下部分即可\n"),v("ul",[v("li",[_._v("进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数")]),_._v(" "),v("li",[_._v("进程的状态：有就绪、运行、挂起、停止等状态")]),_._v(" "),v("li",[_._v("进程切换时需要保存和恢复的一些CPU寄存器")]),_._v(" "),v("li",[_._v("描述虚拟地址空间的信息")]),_._v(" "),v("li",[_._v("描述控制终端的信息")]),_._v(" "),v("li",[_._v("当前工作目录（Current Working Directory）")]),_._v(" "),v("li",[_._v("umask 掩码")]),_._v(" "),v("li",[_._v("文件描述符表，包含很多指向 file 结构体的指针")]),_._v(" "),v("li",[_._v("和信号相关的信息")]),_._v(" "),v("li",[_._v("用户 id 和组 id")]),_._v(" "),v("li",[_._v("会话（Session）和进程组")]),_._v(" "),v("li",[_._v("进程可以使用的资源上限（Resource Limit）\n"),v("ul",[v("li",[_._v("可以使用"),v("code",[_._v("ulimit -a")]),v("strong",[_._v("命令查看资源上限")])]),_._v(" "),v("li",[_._v("使用 "),v("code",[_._v("ulimit 修改项参数 要修改成的值")]),_._v(" "),v("strong",[_._v("修改资源上限")])])])])])])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jackcin877.github.io/image-hosting/Linux/ulimit-%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BD%BF%E7%94%A8%E8%B5%84%E6%BA%90%E4%B8%8A%E9%99%90.4renns267ko0.webp",alt:"ulimit-查看进程可使用资源上限"}})])])}),[],!1,null,null,null);v.default=s.exports}}]);